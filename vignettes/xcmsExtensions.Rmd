---
title: "Extensions to the xcms package"
graphics: yes
output:
  BiocStyle::html_document:
    toc_depth: 2
  BiocStyle::pdf_document:
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Extensions to the xcms package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{xcmsExtensions,xcms,faahKO}
  %\VignettePackage{xcmsExtensions}
  %\VignetteKeywords{MassSpectrometry, Metabolomics}
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

# Introduction

This package provides some functions and utilities extending the functionality
of the `xcms` Bioconductor package. These functions aim to provide a better
integration into the Bioconductor framework (using as much as possible methods
defined in `ProtGenerics` and methods and classes from `MSnbase`; and also
following Bioconductor's coding- and function-naming conventions). Some of the
concepts and definitions used in this package are from [@Smith:2014di].

# New objects introduced by `xcmsExtensions`

To enable a more streamlined and user-friendly access to MS data, the
`xcmsExtensions` package defines the following objects. Some of these are
redundant in functionality and data content with objects in `xcms` that do
however, in most cases, not provide simple access to all of the data or have
other limitations. The `xcms` package defines for example the `xcmsEIC` class
and the `getEIC` method to extract ion chromatograms from an `xcmsSet`
object. The EIC, by default, is however extracted from the *profile* matrix that
represents intensity values aggregated in equal-spaced bins in m/z space. In
addition there exists the `rawEIC` method that extracts m/z, scan index and
corresponding intensity values from the *raw* data, but does not return these as
an `xcmsEIC` object (and does also not report the actual retention time). The
`xcmsExtensions` package tries to solve some of these possible confusions by the
introduction of the below listed classes and their methods.

-   `MSdata`: this is the basic object holding retention time (rt), m/z and
    measured intensities for the rt-mz tuples. To reduce the memory footprint, the
    retention time is internally stored as an `Rle` object, the mz values as
    `numeric` and the intensities as `integer`. By design this object is thought
    to hold only MS data for a subset of a whole MS run, but in principle, it
    could also store all the detected intensities for all m/z and retention/scan
    times. In this latter case the object is somewhat redundant with the `xcmsRaw`
    object, but provides an easier extraction of paired and matched rt, mz and
    intensity values (using the `msData` method).

-   `MSslice`: represents a *wrapper* object for multiple `MSdata` objects, all
    defining the same area (slice) in the m/z-rt space, but across several
    samples. By design, a `MSslice` object is thought to hold data for the same
    slice in each of the samples of an `xcmsSet` object. Note also that, depending
    on the data, each `MSdata` object might have a slightly different range of m/z
    and rt values.

-   `MSsliceList`: a list of several `MSslice` object. If e.g. different slices
    defined by different mz/rt ranges from a single sample (e.g. from a single
    `xcmsRaw` object), these will be stored and returned in a `MSsliceList`. Such
    an `MSsliceList` object could for example be used to store the MS data of all
    peaks identified across all samples.

# Extracting MS data

In this section we show some examples how (raw or binned) data of one or several
MS runs can be extracted from `xcmsRaw`, `xcmsSet`, `MSsliceList`, `MSslice` or
`MSdata` objects.

First we load the example data set from the `xcms` package.

```{r results='silent', message=FALSE}
library(xcmsExtensions)
library(faahKO)
xset <- faahko
```

As described in the previous section, an `MSdata` object simply stores
intensities for rt-m/z tuples and corresponds thus to some degree to a `xcmsRaw`
object from the `xcms` package. Below we are extracting all of the data
(retention time, m/z and intensity) values from one of the raw files of the
`faahko` data set.

```{r warning=FALSE, message=FALSE}
## Extract the full data from an xcmsRaw object.
xraw <- getXcmsRaw(xset, 1)
msFull <- msData(xraw)
msFull
```

Alternatively, we could extract only a portion of the data by specifying an mz
value range and an retention time range with the `mzrange` and `rtrange`
arguments.

```{r warning=FALSE, message=FALSE}
## Extract only a subset of the data (from a slice in M/Z-rt space)
msSub <- msData(xraw, mzrange=c(300, 350), rtrange=c(2700, 2900))
msSub
```

We can extract the retention time, mz values and intensity values using the
`rtime`, `mz` and `intensity` methods.

```{r }
## Get the retention time values
head(rtime(msSub))
## Get the mz values
head(mz(msSub))
## Get the intensity values
head(intensity(msSub))
```

We could also convert the `MSdata` into a numeric matrix.

```{r }
head(as.matrix(msSub))
```

A chromatogram (i.e. intensities along retention time) can be extracted from the
`MSdata` object using the `getChromatogram` method, or plotted using the
`plotChromatogram` method. In its default setting, the `getChromatogram` method
extracts all intensity and retention time pairs in the `MSdata`, aggregating
intensities with the exact same retention time. The argument `FUN` of the method
allows to specify the function to aggregate the intensities. In the default
setting (`FUN` being `max`) only the maximal intensity for a retention time is
selected. Below we extract the chromatogram for the data sub-set.

```{r warning=FALSE}
## Extract the (full) chromatogram; the maximal intensity will be selected
## if two or more values have the same retention time. Otherwise, the data
## will be returnes /as.is/
chr <- getChromatogram(msSub)
head(chr)
nrow(chr)
```

Sometimes it might also be useful to bin the data in retention time dimension
and aggregate the values within these bins as well. The arguments `nbin` or
`binSize` allow to specify either the number of bins along the retention time
axis, or the size of these bins (with the `bins` argument it would be even
possible to provide the actual bins, but in most instances the `nbin` or
`binSize` arguments should suffice). This binning allows to reduce the amount of
data and to group intensities in discrete, equal sized, bins. All intensities
(along the full M/Z range present in the `MSdata` object) with a retention times
that fall within a bin are aggregated with the `FUN` function. Below we bin the
data of the sub-set into 30 bins along the retention time range.

```{r xcmse-bin-chromatogram}
## Bin the values in 30 bins along the retention time range of the MSdata
chrB <- getChromatogram(msSub, nbin=30)
head(chrB)
nrow(chrB)
```

In the example above we the matrix representing the extracted chromatogram has
30 rows, each row representing the aggregated intensities for each bin. Note
that the matrix could also have less than 30 rows, e.g. if no values would be
available for a bin.

We next plot the chromatogram, first without binning and add the binned
chromatogram to that plot.

```{r xcmsExtensions-chromatogram-plot, fig.align='center', fig.width=7, fig.height=4, fig.cap="Extracted chromatogram for the data sub set. With (blue) and without (black) binning along the retention time axis."}
## Plot the chromatogram.
plotChromatogram(msSub, type="l")
## Add the binned chromatogram to the plot.
plotChromatogram(msSub, type="l", col="blue", add=TRUE, nbin=30)
```

With this methods we can also extract the base peak chromatogram
[@Smith:2014di] (BPC, the maximal intensity along the full M/Z range for the
same retention time) or the total ion chromatogram (TIC, the sum of all
intensities along the M/Z dimension for the same retention time). We plot these
two for the `MSdata` representing the full data of the first MS run in the
experiment. For the former we can just use the default setting for the `FUN`
method, for the latter we change `FUN` to `sum`.

```{r xcmsExtensions-chromatogram-plot-bpc-tic, results='hold', fig.align='center', fig.width=7, fig.height=3.5, fig.cap="Base peak chromatogram (BPC) and total ion chromatogram (TIC) for the full data."}
par(mfrow=c(1, 2))
## Plot the BPC.
plotChromatogram(msFull, type="l", main="BPC")
## And the TIC.
plotChromatogram(msFull, type="l", FUN=sum, main="TIC")
```

Analogous to the `getChromatogram`, the `getSpectrum` method allows to extract a
spectrum (i.e. intensities, eventually aggregated for identical retention times,
along the M/Z dimension) from an `MSdata` object, enabling also an optional
binning of values in M/Z dimension. In the example below we refine the MS data
slice for the peak from the example above and plot the chromatogram as well as
the spectrum for it. The MS data could alternatively also extracted as a
two-dimensional matrix with the `mapMatrix` method (see further below in *Data
manipulations* section for an example).

```{r xcmsExtensions-chromatogram-and-spectrum, results='hold', fig.align='center', fig.width=7, fig.height=3.5, fig.cap="Chromatogram and spectrum for the peak."}
rtr <- c(2550, 2700)
mzr <- c(300, 330)
## Extrac the MS data slice
msd <- msData(xraw, mzrange=mzr, rtrange=rtr)
par(mfrow=c(1, 2))
## Plot the chromatogram
plotChromatogram(msd, type="l")
## And the spectrum
plotSpectrum(msd, type="l")
```

The `MSdata` is thus the basic object to store MS data of a single MS
run/sample. Data from different MS runs/samples is represented by, and can be
stored into, a `MSslice` object. This object is supposed to store the data from
the same slice from the 2-dimensional (m/z over rt) MS data across several
samples. In the example below we define a slice representing one of the peaks in
the `faahko` data set shown in Figure 4 in the `xcms` vignette.

Alternatively we could extract an `MSslice` object representing the full MS data
of all samples of an experiment by simply not providing an `rtrange` or
`mzrange`.

```{r warning=FALSE, message=FALSE}
## Extract the chromatogram of a m/z-rt slice across all samples.
## Defining the mz and rt ranges for the peak in the xcms
## vignette (Figure 4).
mzr <- c(300, 330)
rtr <- c(2550, 2700)
mss <- msSlice(xset, rtrange=rtr, mzrange=mzr)
mss
```

Most of the methods defined for `MSdata` objects are also available for
`MSslice` objects. In the example below we thus extract the chromatogram and the
spectrum from the `MSdata` object and get for each of the two as a result a
matrix, rows being either unique retention times or M/Z values and columns
samples.

```{r }
## Extracting the chromatogram from the MSslice object. To reduce the data points
## and enable a better matching of values across samples we use binning on the
## retention time and bin the data in 2 second intervals.
chrM <- getChromatogram(mss, binSize=2)
head(chrM)

## The same with the spectra. Binning into 0.5 M/Z
spcM <- getSpectrum(mss, binSize=0.5)
head(spcM)
```

We can also plot the chromatogram and the spectrum with the `plotChromatogram`
and `plotSpectrum` methods. As above, these methods would also allow to plot the
BPC and the TIC as well as the TIS for all samples within an experiment into the
same plot.

```{r xcmsExtensions-MSslice-chromatogram-spectrum-plot, fig.cap="Chromatogram and spectrum of all samples for the specified MS data slice.", fig.align='center'}
par(mfrow=c(1, 2))
plotChromatogram(mss, binSize=2, type="l", col="#00000050")
plotSpectrum(mss, binSize=0.5, type="h", col="#00000050")
```

In addition, we could use the `image` or the `levelplot` method to plot the
chromatogram or spectrum matrix directly.

```{r xcmsExtensions-MSslice-chromatogram-levelplot-plot, fig.cap="Chromatogram of each sample in the experiment represented as an image plot (levelplot). ", fig.align='center', fig.width=7, fig.height=5}
levelplot(chrM, las=2, xlab="Retention time", ylab="Sample")
```

```{r xcmsExtensions-MSslice-spectrum-levelplot-plot, fig.cap="Spectrum of each sample in the experiment represented as an image plot (levelplot). ", fig.align='center', fig.width=7, fig.height=5}
levelplot(spcM, las=2, xlab="M/Z", ylab="Sample")
```

If multiple different ranges (in M/Z and/or retention time space) are defined,
the `msSlice` method would extract `MSslice` object for each of these and return
the results as a `MSsliceList`.

In the example below we extract a slice of MS data for each of the four peaks
from the `xcms` vignette, Figure 3 from all samples.

```{r }
## Defining the mz and rt ranges.
mzr <- rbind(c(300.0, 300.3),
	     c(301.0, 301.3),
	     c(298.0, 298.3),
	     c(491.0, 491.4))
rtr <- rbind(c(3300, 3450),
	     c(3300, 3450),
	     c(3100, 3250),
	     c(3300, 3500))
## Extracting the MS data slices; we are extracting the raw,
## i.e. unaligned retention times.
msl <- msSlice(xset, rtrange=rtr, mzrange=mzr, rt="raw")
msl
```

Plotting the (base peak) chromatogram for each of the slices.

```{r xcmsExtensions-MSsliceList-peaks-chrom-plot, fig.cap="Base peak chromatogram for each of the MS data slices across all samples.", fig.align='center'}
par(mfrow=c(2, 2))
lapply(slices(msl), plotChromatogram, type="l", col="#00000080")
```

# Data manipulations

One of the simplest data manipulations is to aggregate intensities in bins along
the M/Z or the retention time axis. This might be done to reduce the amount of
data points e.g. to plot the data. Binning in retention time dimension is also
especially useful to match individual intensities across samples, if the
retention times slightly differ. In the example below we aggregate intensities
in bins of size 1 along the M/Z and along the retention time axis (especially in
M/Z dimension this binning might be too coarse in a real world situation). By
default, the maximal signal is selected for each bin, but this can be changed
with the argument `FUN`.

```{r xcmsExtensions-binning-chrom-spec-plot, fig.cap="Chromatogram and Spectrum for the MS data sub-set, grey represents the raw data and blue the binned values. Upper row: binned along the M/Z dimension, lower row: in retention time dimension.", fig.align='center'}
## Using the the same of the MS data from the previous section.
rtr <- c(2550, 2700)
mzr <- c(300, 330)
msd <- msData(xraw, mzrange=mzr, rtrange=rtr)

## Bin along the M/Z range
mzBinned <- binMz(msd, binSize=1)
## And along the retention time
rtBinned <- binRtime(msd, binSize=5)

## Plotting
par(mfrow=c(2, 2))
plotChromatogram(msd, type="l", col="grey")
plotChromatogram(mzBinned, type="l", add=TRUE, col="blue", lty=2)
plotSpectrum(msd, type="l", col="grey")
plotSpectrum(mzBinned, type="l", add=TRUE, col="blue", lty=2)
##
plotChromatogram(msd, type="l", col="grey")
plotChromatogram(rtBinned, type="l", add=TRUE, col="blue", lty=2)
plotSpectrum(msd, type="l", col="grey")
plotSpectrum(rtBinned, type="l", add=TRUE, col="blue", lty=2)
```

To bin the data matrix in both dimensions, the `binMzRtime` method can be used.

The MS data can also be extracted as a two-dimensional matrix, with rows being
the M/Z and columns the retention time values for each measurement. This might
e.g. be useful to plot the data using the `image` or `levelplot`
functions. Below we first bin the `MSdata` in both, M/Z and retention time,
extract the resulting MS data matrix and plot it. Below we plot the matrix using
the `image` function, to use the `levelplot` we first have to cast the
`dgCMatrix` into a *normal* matrix using the `as.matrix` function.

```{r xcmsExtensions-binning-mapMatrix-plot, fig.cal="Image plot of the binned MS data.", fig.align='center'}
## We bin the data along the retention time in 5 second intervals and into 20
## bins along the M/Z dimension.
M <- mapMatrix(binMzRtime(msd, rtBinSize=5, mzNbin=20))
image(M, xlab="Retention time", ylab="M/Z")
```

The same binning can also be applied to `MSslice` and `MSsliceList`
objects. For both methods, the `mzrange` or `rtrange` across all samples is
first cut into intervals and the binning is then performed, for each sample
separately, but using the same bins.

# Simple peak/compound identification

One of the major problems in the metabolomics data analysis workflow is the
identification of the compounds. To facilitate this step, the `xcmsExtensions`
package provides an internal, simple, database that enables a fast and easy
identification based on the compound mass.

In the code chunk below we show some basic information on this database, that is
bound to the variable name `scDb` (for *simple compound database*).

```{r results='hold'}
## Show some information on the database.
scDb
```

Some of the methods defined by the `AnnotationDbi` Bioconductor package are
implemented, thus we can ask for the available columns in the database with the
`columns` method or get the SQLite database connection with the `dbconn`
method.

```{r }
## List the available columns.
columns(scDb)
```

To retrieve compounds in this database we can use the `compounds` method, that
by default will return all of the available compounds. The `xcmsExtensions`
package implements however also the filtering framework introduced by
Bioconductor's `ensembldb` package. Thus, we can use an `CompoundidFilter` to
select only specific compounds from the database.

```{r }
## Get all of the compounds from the database.
allCmps <- compounds(scDb)
nrow(allCmps)
```

The `compounds` method returns all database columns from the respective database
table from the database. The method's `columns` argument allows to select only
specific columns (selected from the available ones returned by the `columns`
method shown above) that should be returned.

As stated above, we can use this database also for a simple, mass based,
peak/compound identification. The `mzmatch` method compares the provided masses
with the M/Z values of all of the compounds in the database and returns for each
mass all compounds that match the specified mass given a user specified mass
difference threshold. This allowed difference can be defined with the `mzdev`
and `ppm` arguments. By default, the method returns all matches allowing a
difference of 10 ppm.

```{r }
## Defining compound masses.
comps <- c(300.1898, 298.1508, 491.2000, 169.13481, 169.1348)

## Searching for matches in the database.
Res <- mzmatch(comps, scDb)

Res
```

The results are returned as a `list`, elements being a matrix with the match(es)
for each specified mass. The column `idx` of the matrix contains the compound
IDs and the column `deltaMz` the difference between the specified mass and the
compound's M/Z value. In the code chunk below we're defining an
`CompoundidFilter` for the identified compounds of the 4th mass and return its
name and inchi key from the database.

```{r }
## Define CompoundidFilter for the matches of the selected mass
cf <- CompoundidFilter(Res[[4]][, 1])

## Getting the compounds' names and inchi keys from the database
cmps <- compounds(scDb, filter=cf, columns=c("name", "inchikey"))
cmps
```

# Using `xcmsExtensions` for an updated `xcms` data analysis workflow

TODO: use the workflow in `xcms` but use as much as possible the stuff from the
`xcmsExtensions`.

# Alternative way to access data in `xcmsRaw` objects

The `getData` method is an alternative method that can be used to extract paired
retention time, m/z and intensity values from an `xcmsRaw` object. The advantage
over the `msData` method described in the previous method is, that it allows
also a sub-setting by intensities.

Loading the libraries and the `xcmsRaw` object.

```{r results='silent', message=FALSE}
library(xcmsExtensions)
library(faahKO)
xset <- faahko
## Getting the raw data for the first data file.
xraw <- getXcmsRaw(xset)
```

The raw data of an LC/GC-MS run is stored in an `xcmsRaw` object, more
specifically, in the slots `@scantime`, `@env$mz`, `@env$intensity`. Extracting
data from such a `xcmsRaw` object can however be somewhat cumbersome, especially
when we want to extract only (eventually multiple) sub-sets of data. Also, for
memory reasons, the length of the `@scantime` slot does not match the length of
the `@env$mz` slot as it stores only the distinct scan/measurement time points.
We can however use the `scantimes` method to extract a numeric vector that
matches the length of the `@env$mz` and `@env$intensity` slots, thus specifying
the scan time for each of these data points.

```{r }
## What's the length of data points we have?
length(xraw@env$mz)
## And the length of scan times?
length(xraw@scantime)

## Extract the scan times matching the individual data points.
head(scantimes(xraw))
length(scantimes(xraw))
```

The data in an R-object should however not be accessed directly (i.e. accessing
the slots), but ideally through an *getter* methods. Thus, to extract the raw
data from an `xcmsRaw` object we can use the `getData` method. We could also use
the `rawMat` method defined in the `xcms` package, but the `getData` should be
preferably used, as it is also faster and extracts always correct sub-sets if
sub-setting is done on retention time ranges.

```{r }
## Get the full data from the object
dim(getData(xraw))
head(getData(xraw))

## Extract only a subset of data specified by an retention time range.
datmat <- getData(xraw, rtrange=c(2509, 2530))
dim(datmat)

## We can also specify both, a retention time and a mz range.
datmat <- getData(xraw, rtrange=c(2509, 2530), mzrange=c(301, 302.003))
```

Besides sub-setting by retention time and m/z ranges it is also possible to
extract data sub-sets defined by an intensity range.

```{r }
## Use and intensity range: all with a signal higher than 300
```

And finally, we can also specify multiple retention time and or m/z (or
intensity) ranges to extract multiple sub-sets.

```{r }
```

Note that, if we load an `xcmsRaw` object for a `xcmsSet` object after having
applied retention time correction, the retention times (scan time) we extract
from that object will correspond to the corrected ones.

```{r results='hold'}
## Grouping (alignment) of peaks/features
xset <- group(xset)
## Retention time correction
xset <- retcor(xset)
## Extract "raw" data; corrected retention times will be applied to the raw data.
xraw2 <- getXcmsRaw(xset)
```

Extracting data by directly accessing the slots of an R-object is however no

# References
