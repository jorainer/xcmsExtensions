#+TITLE: Extensions to the xcms package
#+AUTHOR:    Johannes Rainer
#+EMAIL:     johannes.rainer@eurac.edu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: exports code
#+PROPERTY: session *R*

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+BEGIN_HTML
---
title: "Extensions to the xcms package"
graphics: yes
output:
  BiocStyle::html_document:
    toc_depth: 2
  BiocStyle::pdf_document:
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Extensions to the xcms package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{xcmsExtensions,xcms,faahKO}
  %\VignettePackage{xcmsExtensions}
  %\VignetteKeywords{MassSpectrometry, Metabolomics}
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

#+END_HTML

# #+BEGIN_SRC R :ravel echo=FALSE, results='asis', message=FALSE
#   BiocStyle::markdown()
# #+END_SRC

* How to export this to a =Rmd= vignette			   :noexport:

Use =ox-ravel= to export this file as an R markdown file (=C-c C-e m r=). That
way we don't need to edit the resulting =Rmd= file.

* How to export this to a =Rnw= vignette 			   :noexport:

*Note*: this is deprecated! Use the =Rmd= export instead!

Use =ox-ravel= from the =orgmode-accessories= package to export this file to a
=Rnw= file. After export edit the generated =Rnw= in the following way:

1) Delete all =\usepackage= commands.
2) Move the =<<style>>= code chunk before the =\begin{document}= and before
   =\author=.
3) Move all =%\Vignette...= lines at the start of the file (even before
   =\documentclass=).
4) Replace =\date= with =\date{Modified: 21 October, 2013. Compiled: \today}=
5) Eventually search for all problems with =texttt=, i.e. search for pattern
   ="==.

Note: use =:ravel= followed by the properties for the code chunk headers,
e.g. =:ravel results='hide'=. Other options for knitr style options are:
+ =results=: ='hide'= (hides all output, not warnings or messages), ='asis'=,
  ='markup'= (the default).
+ =warning=: =TRUE= or =FALSE= whether warnings should be displayed.
+ =message=: =TRUE= or =FALSE=, same as above.
+ =include=: =TRUE= or =FALSE=, whether the output should be included into the
  final document (code is still evaluated).

* Working with =svn= and =git=					   :noexport:

First check out the svn repo using git:

=git svn clone svn+ssh://svn@source.gm.eurac.edu/chrisUtils --stdlayout=.

Pull the existing =git= repository to this /new/ repo: from within the folder call

=git pull ~/Projects/git/chrisUtils=

Eventually rebasing it again (shouldn't do anything actually).

=git svn rebase=

Commiting (if there is anything to commit) and push it to svn:

=git svn dcommit=.

Now, if we want to create a tag (say we have done a release).

=git svn tag=.


Based on
http://stackoverflow.com/questions/22527867/adding-svn-remote-to-existing-git-repo.



* Introduction

This package provides some functions and utilities extending the functionality
of the =xcms= Bioconductor package. These functions aim to provide a better
integration into the Bioconductor framework (using as much as possible methods
defined in =ProtGenerics= and methods and classes from =MSnbase=; and also
following Bioconductor's coding- and function-naming conventions). Some of the
concepts and definitions used in this package are from \cite{Smith:2014di}.


* New objects introduced by =xcmsExtensions=

To enable a more streamlined and user-friendly access to MS data, the
=xcmsExtensions= package defines the following objects. Some of these are
redundant in functionality and data content with objects in =xcms= that do
however, in most cases, not provide simple access to all of the data or have
other limitations. The =xcms= package defines for example the =xcmsEIC= class
and the =getEIC= method to extract ion chromatograms from an =xcmsSet=
object. The EIC, by default, is however extracted from the /profile/ matrix that
represents intensity values aggregated in equal-spaced bins in m/z space. In
addition there exists the =rawEIC= method that extracts m/z, scan index and
corresponding intensity values from the /raw/ data, but does not return these as
an =xcmsEIC= object (and does also not report the actual retention time). The
=xcmsExtensions= package tries to solve some of these possible confusions by the
introduction of the below listed classes and their methods.

+ =MSdata=: this is the basic object holding retention time (rt), m/z and
  measured intensities for the rt-mz tuples. To reduce the memory footprint, the
  retention time is internally stored as an =Rle= object, the mz values as
  =numeric= and the intensities as =integer=. By design this object is thought
  to hold only MS data for a subset of a whole MS run, but in principle, it
  could also store all the detected intensities for all m/z and retention/scan
  times. In this latter case the object is somewhat redundant with the =xcmsRaw=
  object, but provides an easier extraction of paired and matched rt, mz and
  intensity values (using the =msData= method).

+ =MSslice=: represents a /wrapper/ object for multiple =MSdata= objects, all
  defining the same area (slice) in the m/z-rt space, but across several
  samples. By design, a =MSslice= object is thought to hold data for the same
  slice in each of the samples of an =xcmsSet= object. Note also that, depending
  on the data, each =MSdata= object might have a slightly different range of m/z
  and rt values.

+ =MSsliceList=: a list of several =MSslice= object. If e.g. different slices
  defined by different mz/rt ranges from a single sample (e.g. from a single
  =xcmsRaw= object), these will be stored and returned in a =MSsliceList=. Such
  an =MSsliceList= object could for example be used to store the MS data of all
  peaks identified across all samples.

* Extracting MS data

In this section we show some examples how (raw or binned) data of one or several
MS runs can be extracted from =xcmsRaw=, =xcmsSet=, =MSsliceList=, =MSslice= or
=MSdata= objects.

First we load the example data set from the =xcms= package.

#+BEGIN_SRC R :ravel results='silent', message=FALSE
  library(xcmsExtensions)
  library(faahKO)
  xset <- faahko
#+END_SRC

As described in the previous section, an =MSdata= object simply stores
intensities for rt-m/z tuples and corresponds thus to some degree to a =xcmsRaw=
object from the =xcms= package. Below we are extracting all of the data
(retention time, m/z and intensity) values from one of the raw files of the
=faahko= data set.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Extract the full data from an xcmsRaw object.
  xraw <- getXcmsRaw(xset, 1)
  msFull <- msData(xraw)
  msFull
#+END_SRC

Alternatively, we could extract only a portion of the data by specifying an mz
value range and an retention time range with the =mzrange= and =rtrange=
arguments.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Extract only a subset of the data (from a slice in M/Z-rt space)
  msSub <- msData(xraw, mzrange=c(300, 350), rtrange=c(2700, 2900))
  msSub
#+END_SRC

We can extract the retention time, mz values and intensity values using the
=rtime=, =mz= and =intensity= methods.

#+BEGIN_SRC R
  ## Get the retention time values
  head(rtime(msSub))
  ## Get the mz values
  head(mz(msSub))
  ## Get the intensity values
  head(intensity(msSub))
#+END_SRC

We could also convert the =MSdata= into a numeric matrix.

#+BEGIN_SRC R
  head(as.matrix(msSub))
#+END_SRC

# Extract the chromatogram, plot the total ion chromatogram and the base peak
# chromatogram.

A chromatogram (i.e. intensities along retention time) can be extracted from the
=MSdata= object using the =getChromatogram= method, or plotted using the
=plotChromatogram= method. In its default setting, the =getChromatogram= method
extracts all intensity and retention time pairs in the =MSdata=, aggregating
intensities with the exact same retention time. The argument =FUN= of the method
allows to specify the function to aggregate the intensities. In the default
setting (=FUN= being =max=) only the maximal intensity for a retention time is
selected. Below we extract the chromatogram for the data sub-set.

#+BEGIN_SRC R :ravel warning=FALSE
  ## Extract the (full) chromatogram; the maximal intensity will be selected
  ## if two or more values have the same retention time. Otherwise, the data
  ## will be returnes /as.is/
  chr <- getChromatogram(msSub)
  head(chr)
  nrow(chr)
#+END_SRC

Sometimes it might also be useful to bin the data in retention time dimension
and aggregate the values within these bins as well. The arguments =nbin= or
=binSize= allow to specify either the number of bins along the retention time
axis, or the size of these bins (with the =bins= argument it would be even
possible to provide the actual bins, but in most instances the =nbin= or
=binSize= arguments should suffice). This binning allows to reduce the amount of
data and to group intensities in discrete, equal sized, bins. All intensities
(along the full M/Z range present in the =MSdata= object) with a retention times
that fall within a bin are aggregated with the =FUN= function. Below we bin the
data of the sub-set into 30 bins along the retention time range.

#+NAME: xcmse-bin-chromatogram
#+BEGIN_SRC R
  ## Bin the values in 30 bins along the retention time range of the MSdata
  chrB <- getChromatogram(msSub, nbin=30)
  head(chrB)
  nrow(chrB)
#+END_SRC

In the example above we the matrix representing the extracted chromatogram has
30 rows, each row representing the aggregated intensities for each bin. Note
that the matrix could also have less than 30 rows, e.g. if no values would be
available for a bin.

We next plot the chromatogram, first without binning and add the binned
chromatogram to that plot.

#+NAME: xcmsExtensions-chromatogram-plot
#+BEGIN_SRC R :ravel fig.align='center', fig.width=7, fig.height=4, fig.cap="Extracted chromatogram for the data sub set. With (blue) and without (black) binning along the retention time axis."
  ## Plot the chromatogram.
  plotChromatogram(msSub, type="l")
  ## Add the binned chromatogram to the plot.
  plotChromatogram(msSub, type="l", col="blue", add=TRUE, nbin=30)
#+END_SRC

With this methods we can also extract the base peak chromatogram
\cite{Smith:2014di} (BPC, the maximal intensity along the full M/Z range for the
same retention time) or the total ion chromatogram (TIC, the sum of all
intensities along the M/Z dimension for the same retention time). We plot these
two for the =MSdata= representing the full data of the first MS run in the
experiment. For the former we can just use the default setting for the =FUN=
method, for the latter we change =FUN= to =sum=.

#+NAME: xcmsExtensions-chromatogram-plot-bpc-tic
#+BEGIN_SRC R :ravel results='hold', fig.align='center', fig.width=7, fig.height=3.5, fig.cap="Base peak chromatogram (BPC) and total ion chromatogram (TIC) for the full data."
  par(mfrow=c(1, 2))
  ## Plot the BPC.
  plotChromatogram(msFull, type="l", main="BPC")
  ## And the TIC.
  plotChromatogram(msFull, type="l", FUN=sum, main="TIC")
#+END_SRC

# Extract the spectrum.
Analogous to the =getChromatogram=, the =getSpectrum= method allows to extract a
spectrum (i.e. intensities, eventually aggregated for identical retention times,
along the M/Z dimension) from an =MSdata= object, enabling also an optional
binning of values in M/Z dimension. In the example below we refine the MS data
slice for the peak from the example above and plot the chromatogram as well as
the spectrum for it. The MS data could alternatively also extracted as a
two-dimensional matrix with the =mapMatrix= method (see further below in /Data
manipulations/ section for an example).

#+NAME: xcmsExtensions-chromatogram-and-spectrum
#+BEGIN_SRC R :ravel results='hold', fig.align='center', fig.width=7, fig.height=3.5, fig.cap="Chromatogram and spectrum for the peak."
  rtr <- c(2550, 2700)
  mzr <- c(300, 330)
  ## Extrac the MS data slice
  msd <- msData(xraw, mzrange=mzr, rtrange=rtr)
  par(mfrow=c(1, 2))
  ## Plot the chromatogram
  plotChromatogram(msd, type="l")
  ## And the spectrum
  plotSpectrum(msd, type="l")
#+END_SRC

The =MSdata= is thus the basic object to store MS data of a single MS
run/sample. Data from different MS runs/samples is represented by, and can be
stored into, a =MSslice= object. This object is supposed to store the data from
the same slice from the 2-dimensional (m/z over rt) MS data across several
samples. In the example below we define a slice representing one of the peaks in
the =faahko= data set shown in Figure 4 in the =xcms= vignette.

Alternatively we could extract an =MSslice= object representing the full MS data
of all samples of an experiment by simply not providing an =rtrange= or
=mzrange=.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Extract the chromatogram of a m/z-rt slice across all samples.
  ## Defining the mz and rt ranges for the peak in the xcms
  ## vignette (Figure 4).
  mzr <- c(300, 330)
  rtr <- c(2550, 2700)
  mss <- msSlice(xset, rtrange=rtr, mzrange=mzr)
  mss
#+END_SRC

Most of the methods defined for =MSdata= objects are also available for
=MSslice= objects. In the example below we thus extract the chromatogram and the
spectrum from the =MSdata= object and get for each of the two as a result a
matrix, rows being either unique retention times or M/Z values and columns
samples.

#+BEGIN_SRC R
  ## Extracting the chromatogram from the MSslice object. To reduce the data points
  ## and enable a better matching of values across samples we use binning on the
  ## retention time and bin the data in 2 second intervals.
  chrM <- getChromatogram(mss, binSize=2)
  head(chrM)

  ## The same with the spectra. Binning into 0.5 M/Z
  spcM <- getSpectrum(mss, binSize=0.5)
  head(spcM)
#+END_SRC

We can also plot the chromatogram and the spectrum with the =plotChromatogram=
and =plotSpectrum= methods. As above, these methods would also allow to plot the
BPC and the TIC as well as the TIS for all samples within an experiment into the
same plot.

#+NAME: xcmsExtensions-MSslice-chromatogram-spectrum-plot
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and spectrum of all samples for the specified MS data slice.", fig.align='center'
  par(mfrow=c(1, 2))
  plotChromatogram(mss, binSize=2, type="l", col="#00000050")
  plotSpectrum(mss, binSize=0.5, type="h", col="#00000050")

#+END_SRC

In addition, we could use the =image= or the =levelplot= method to plot the
chromatogram or spectrum matrix directly.

#+NAME: xcmsExtensions-MSslice-chromatogram-levelplot-plot
#+BEGIN_SRC R :ravel fig.cap="Chromatogram of each sample in the experiment represented as an image plot (levelplot). ", fig.align='center', fig.width=7, fig.height=5
  levelplot(chrM, las=2, xlab="Retention time", ylab="Sample")
#+END_SRC

#+NAME: xcmsExtensions-MSslice-spectrum-levelplot-plot
#+BEGIN_SRC R :ravel fig.cap="Spectrum of each sample in the experiment represented as an image plot (levelplot). ", fig.align='center', fig.width=7, fig.height=5
  levelplot(spcM, las=2, xlab="M/Z", ylab="Sample")
#+END_SRC

# MSsliceList objects
If multiple different ranges (in M/Z and/or retention time space) are defined,
the =msSlice= method would extract =MSslice= object for each of these and return
the results as a =MSsliceList=.

In the example below we extract a slice of MS data for each of the four peaks
from the =xcms= vignette, Figure 3 from all samples.

#+BEGIN_SRC R
  ## Defining the mz and rt ranges.
  mzr <- rbind(c(300.0, 300.3),
               c(301.0, 301.3),
               c(298.0, 298.3),
               c(491.0, 491.4))
  rtr <- rbind(c(3300, 3450),
               c(3300, 3450),
               c(3100, 3250),
               c(3300, 3500))
  ## Extracting the MS data slices; we are extracting the raw,
  ## i.e. unaligned retention times.
  msl <- msSlice(xset, rtrange=rtr, mzrange=mzr, rt="raw")
  msl
#+END_SRC

Plotting the (base peak) chromatogram for each of the slices.

#+NAME: xcmsExtensions-MSsliceList-peaks-chrom-plot
#+BEGIN_SRC R :ravel fig.cap="Base peak chromatogram for each of the MS data slices across all samples.", fig.align='center'
  par(mfrow=c(2, 2))
  lapply(slices(msl), plotChromatogram, type="l", col="#00000080")
#+END_SRC


* Data manipulations

One of the simplest data manipulations is to aggregate intensities in bins along
the M/Z or the retention time axis. This might be done to reduce the amount of
data points e.g. to plot the data. Binning in retention time dimension is also
especially useful to match individual intensities across samples, if the
retention times slightly differ. In the example below we aggregate intensities
in bins of size 1 along the M/Z and along the retention time axis (especially in
M/Z dimension this binning might be too coarse in a real world situation). By
default, the maximal signal is selected for each bin, but this can be changed
with the argument =FUN=.

#+NAME: xcmsExtensions-binning-chrom-spec-plot
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and Spectrum for the MS data sub-set, grey represents the raw data and blue the binned values. Upper row: binned along the M/Z dimension, lower row: in retention time dimension.", fig.align='center'
  ## Using the the same of the MS data from the previous section.
  rtr <- c(2550, 2700)
  mzr <- c(300, 330)
  msd <- msData(xraw, mzrange=mzr, rtrange=rtr)

  ## Bin along the M/Z range
  mzBinned <- binMz(msd, binSize=1)
  ## And along the retention time
  rtBinned <- binRtime(msd, binSize=5)

  ## Plotting
  par(mfrow=c(2, 2))
  plotChromatogram(msd, type="l", col="grey")
  plotChromatogram(mzBinned, type="l", add=TRUE, col="blue", lty=2)
  plotSpectrum(msd, type="l", col="grey")
  plotSpectrum(mzBinned, type="l", add=TRUE, col="blue", lty=2)
  ##
  plotChromatogram(msd, type="l", col="grey")
  plotChromatogram(rtBinned, type="l", add=TRUE, col="blue", lty=2)
  plotSpectrum(msd, type="l", col="grey")
  plotSpectrum(rtBinned, type="l", add=TRUE, col="blue", lty=2)
#+END_SRC

To bin the data matrix in both dimensions, the =binMzRtime= method can be used.

The MS data can also be extracted as a two-dimensional matrix, with rows being
the M/Z and columns the retention time values for each measurement. This might
e.g. be useful to plot the data using the =image= or =levelplot=
functions. Below we first bin the =MSdata= in both, M/Z and retention time,
extract the resulting MS data matrix and plot it. Below we plot the matrix using
the =image= function, to use the =levelplot= we first have to cast the
=dgCMatrix= into a /normal/ matrix using the =as.matrix= function.

#+NAME: xcmsExtensions-binning-mapMatrix-plot
#+BEGIN_SRC R :ravel fig.cal="Image plot of the binned MS data.", fig.align='center'
  ## We bin the data along the retention time in 5 second intervals and into 20
  ## bins along the M/Z dimension.
  M <- mapMatrix(binMzRtime(msd, rtBinSize=5, mzNbin=20))
  image(M, xlab="Retention time", ylab="M/Z")
#+END_SRC

The same binning can also be applied to =MSslice= and =MSsliceList=
objects. For both methods, the =mzrange= or =rtrange= across all samples is
first cut into intervals and the binning is then performed, for each sample
separately, but using the same bins.



* Simple peak/compound identification

One of the major problems in the metabolomics data analysis workflow is the
identification of the compounds. To facilitate this step, the =xcmsExtensions=
package provides an internal, simple, database that enables a fast and easy
identification based on the compound mass.

In the code chunk below we show some basic information on this database, that is
bound to the variable name =scDb= (for /simple compound database/).

#+BEGIN_SRC R :ravel results='hold'
  ## Show some information on the database.
  scDb
#+END_SRC

Some of the methods defined by the =AnnotationDbi= Bioconductor package are
implemented, thus we can ask for the available columns in the database with the
=columns= method or get the SQLite database connection with the =dbconn=
method.

#+BEGIN_SRC R
  ## List the available columns.
  columns(scDb)
#+END_SRC

To retrieve compounds in this database we can use the =compounds= method, that
by default will return all of the available compounds. The =xcmsExtensions=
package implements however also the filtering framework introduced by
Bioconductor's =ensembldb= package. Thus, we can use an =CompoundidFilter= to
select only specific compounds from the database.

#+BEGIN_SRC R
  ## Get all of the compounds from the database.
  allCmps <- compounds(scDb)
  nrow(allCmps)
#+END_SRC

The =compounds= method returns all database columns from the respective database
table from the database. The method's =columns= argument allows to select only
specific columns (selected from the available ones returned by the =columns=
method shown above) that should be returned.

As stated above, we can use this database also for a simple, mass based,
peak/compound identification. The =mzmatch= method compares the provided masses
with the M/Z values of all of the compounds in the database and returns for each
mass all compounds that match the specified mass given a user specified mass
difference threshold. This allowed difference can be defined with the =mzdev=
and =ppm= arguments. By default, the method returns all matches allowing a
difference of 10 ppm.

#+BEGIN_SRC R
  ## Defining compound masses.
  comps <- c(300.1898, 298.1508, 491.2000, 169.13481, 169.1348)

  ## Searching for matches in the database.
  Res <- mzmatch(comps, scDb)

  Res
#+END_SRC

The results are returned as a =list=, elements being a matrix with the match(es)
for each specified mass. The column =idx= of the matrix contains the compound
IDs and the column =deltaMz= the difference between the specified mass and the
compound's M/Z value. In the code chunk below we're defining an
=CompoundidFilter= for the identified compounds of the 4th mass and return its
name and inchi key from the database.

#+BEGIN_SRC R
  ## Define CompoundidFilter for the matches of the selected mass
  cf <- CompoundidFilter(Res[[4]][, 1])

  ## Getting the compounds' names and inchi keys from the database
  cmps <- compounds(scDb, filter=cf, columns=c("name", "inchikey"))
  cmps
#+END_SRC


* Using =xcmsExtensions= for an updated =xcms= data analysis workflow

TODO: use the workflow in =xcms= but use as much as possible the stuff from the
=xcmsExtensions=.


* Alternative way to access data in =xcmsRaw= objects

The =getData= method is an alternative method that can be used to extract paired
retention time, m/z and intensity values from an =xcmsRaw= object. The advantage
over the =msData= method described in the previous method is, that it allows
also a sub-setting by intensities.

Loading the libraries and the =xcmsRaw= object.

#+BEGIN_SRC R :ravel results='silent', message=FALSE
  library(xcmsExtensions)
  library(faahKO)
  xset <- faahko
  ## Getting the raw data for the first data file.
  xraw <- getXcmsRaw(xset)
#+END_SRC

The raw data of an LC/GC-MS run is stored in an =xcmsRaw= object, more
specifically, in the slots =@scantime=, =@env$mz=, =@env$intensity=. Extracting
data from such a =xcmsRaw= object can however be somewhat cumbersome, especially
when we want to extract only (eventually multiple) sub-sets of data. Also, for
memory reasons, the length of the =@scantime= slot does not match the length of
the =@env$mz= slot as it stores only the distinct scan/measurement time points.
We can however use the =scantimes= method to extract a numeric vector that
matches the length of the =@env$mz= and =@env$intensity= slots, thus specifying
the scan time for each of these data points.

#+BEGIN_SRC R
  ## What's the length of data points we have?
  length(xraw@env$mz)
  ## And the length of scan times?
  length(xraw@scantime)

  ## Extract the scan times matching the individual data points.
  head(scantimes(xraw))
  length(scantimes(xraw))
#+END_SRC

The data in an R-object should however not be accessed directly (i.e. accessing
the slots), but ideally through an /getter/ methods. Thus, to extract the raw
data from an =xcmsRaw= object we can use the =getData= method. We could also use
the =rawMat= method defined in the =xcms= package, but the =getData= should be
preferably used, as it is also faster and extracts always correct sub-sets if
sub-setting is done on retention time ranges.

#+BEGIN_SRC R
  ## Get the full data from the object
  dim(getData(xraw))
  head(getData(xraw))

  ## Extract only a subset of data specified by an retention time range.
  datmat <- getData(xraw, rtrange=c(2509, 2530))
  dim(datmat)

  ## We can also specify both, a retention time and a mz range.
  datmat <- getData(xraw, rtrange=c(2509, 2530), mzrange=c(301, 302.003))
#+END_SRC

Besides sub-setting by retention time and m/z ranges it is also possible to
extract data sub-sets defined by an intensity range.

#+BEGIN_SRC R
  ## Use and intensity range: all with a signal higher than 300
#+END_SRC

And finally, we can also specify multiple retention time and or m/z (or
intensity) ranges to extract multiple sub-sets.

#+BEGIN_SRC R

#+END_SRC

Note that, if we load an =xcmsRaw= object for a =xcmsSet= object after having
applied retention time correction, the retention times (scan time) we extract
from that object will correspond to the corrected ones.

#+BEGIN_SRC R :ravel results='hold'
  ## Grouping (alignment) of peaks/features
  xset <- group(xset)
  ## Retention time correction
  xset <- retcor(xset)
  ## Extract "raw" data; corrected retention times will be applied to the raw data.
  xraw2 <- getXcmsRaw(xset)
#+END_SRC

Extracting data by directly accessing the slots of an R-object is however no


* Standardization of names etc					   :noexport:

We base the naming convention of methods classes etc on the review from Smith et
al. \cite{Smith:2014di} and will implement as many methods and classes as
possible (and meaningful) from the =ProtGenerics= and =MSnbase= packages.

+ *Definitions*
  + *chromatogram*: intensity /vs/ (retention) time of the analytes.
  + *(mass) spectrum*: intensity /vs/ m/z; all points with a single retention time
    value (MS1, can be measured by MSMS again -> MS2).
  + *total ion spectrum (TIS)*: sum of all ion counts (intensity) with one RT
    (i.e. the sum of all spectra). Basically the sum of the signal per m/z over
    all RT resulting in intensity /vs/ m/z (intensity /vs/ m/z).
  + *total ion chromatogram (TIC)*: sum of all ion chromatograms, i.e. sum of ion
    counts per RT over all m/z (intensity /vs/ RT).
  + *extracted ion chromatogram (XIC)*: chromatogram (intensity /vs/ RT) for a
    fixed m/z.
  + *base peak chromatogram (BPC)*: most intense signal across m/z for each RT
    (intensity /vs/ RT).
  + *isotope trace*: signal produced by a single ion of a single analyte at a
    particular charge state, fixed m/z (intensity /vs/ RT for a fixed m/z). Sort
    of a peak in RT for a fixed m/z.
  + *isotopic envelope trace* a.k.a. *feature*: group of isotopic traces of a
    single analyte at a particular charge state (intensity /vs/ RT /vs/
    m/z). Represents all intensities/peaks in a RT, m/z region.

+ =ProtGenerics=

+ =MSnbase=

  - =MSmap= object.


* Creation of an =SimpleCompoundDb=				   :noexport:
:PROPERTIES:
:eval: never
:END:

Assuming we have downloaded the whole HMDB (http://www.hmdb.ca/) content as a
zip (http://www.hmdb.ca/downloads) and have unzipped it to the folder
=~/tmp/HMDB=. Note that we have to delete the large xml file containing all of
the metabolites first, i.e. the /hmdb_metabolites.xml/ file.

#+BEGIN_SRC R
  dbFile <- xcmsExtensions:::.createSimpleCompoundDb(hmdbPath="~/tmp/HMDB",
                                                     hmdbVersion="2016-04-03")
#+END_SRC

Alternatively we can also split the file into small peaces... hm , doesn't work!!!

=csplit hmdb_metabolites.xml '/^<?xml version="1.0" encoding="UTF-8"?>$/'=

=awk '/<?xml/{filename=NR".xml"}; {print > filename}' hmdb_metabolites.xml=


* TODOs								   :noexport:

** CANCELED Implement =getXIC= methods.
   CLOSED: [2016-04-05 Tue 15:22]
   - State "CANCELED"   from "TODO"       [2016-04-05 Tue 15:22] \\
     Can all be done with the =plotChromatogram= method.
+ [ ] =getXIC=: providing rtrange, mzrange, extract the ion chromatogram.
+ [ ] =getTIC=:
+ [ ] =getBPC=:
+ [ ] =getTIS=:
+ [ ] =getWhatever=: just extract everything from the 2-dimensional thing.

** TODO Implement =calibrate= method.
** DONE Stuff to work with the /HMDB/ xml files?
   CLOSED: [2016-04-05 Tue 15:22]
   - State "DONE"       from "TODO"       [2016-04-05 Tue 15:22]
** DONE =scantime= method for =xcmsRaw=.
   CLOSED: [2016-03-30 Wed 15:53]
   - State "DONE"       from "TODO"       [2016-03-30 Wed 15:53]
** DONE =MSslice= class [5/5]
   CLOSED: [2016-04-05 Tue 15:22]
   - State "DONE"       from "TODO"       [2016-04-05 Tue 15:22]
The =MSslice= represents a part of the data defined by an =rtrange= and an
=mzrange=. Would be nice to store that for one such range across several
files. But this again requires that the times AND mz are synced.

+ [X] Extract such an object using =msSlice= from an =xcmsSet= or =xcmsRaw=
  object.
+ [X] =plot= method: two different ones, one for the spectrum (intensity vs mz)
  and one for the chromatogram (intensity vs rt). In both cases we have to sum
  up intensities for /close/ values either on rt or on mz.
+ [X] Documentation.
+ [X] Examples to the vignette.
+ [X] =binMz=, =binRt= and both.

** TODO =MSsliceList= class [2/6]

Represents multiple =MSslice= objects. Each one defined by its own mz/rt region.

+ [X] Implement =[= to subset the list.
+ [X] Implement =[[= to extract individual (single) elements.
+ [ ] Add names slot.
+ [ ] Documentation.
+ [ ] Examples to the vignette.
+ [ ] =binMz=, =binRt= and both.

** DONE =MSdata= class [8/8]
   CLOSED: [2016-04-05 Tue 15:22]
   - State "DONE"       from "TODO"       [2016-04-05 Tue 15:22]
+ [X] =chromatogram=: plot the chromatogram of the =MSdata= object.
+ [X] =getChromatogram=: extract a chromatogram.
+ [X] =plotChromatogram=: plot a chromatogram; uses =getChromatogram= to extract
  the chromatogram.
+ [X] =getSpectrum=: extract a spectrum (intensity over m/z for one given
  (small) rt range).
+ [X] =plotSpectrum=: plot that.
+ [X] =msMap= method for =MSdata=: convert the =MSdata= into a =MSmap=.
+ [X] =binMzRtime= method to bin in both dimensions!
+ [X] =mapMatrix= method to extract a matrix representing the data (two-d).


** TODO Easy identification database. [1/3]

+ [X] Create a simple database (table) with mass, internal id, external id,
  source and name to easily and fast identify peaks based on mass alone.
+ [ ] Method =simpleIdentify= method.
+ [ ] Implement a method =mzmatch= that allows to
  - Identify e.g. peaks in the data (if applied to an =xcmsSet= object).
  - Annotate peaks (if applied to an annotation database object).

** TODO shiny app to visualize the data of an =xcmsSet= or =xcmsRaw= object.

** TODO Finish help and vignette [4/5]

+ [X] Help on =SimpleCompoundDb=.
+ [X] Help on =CompoundidFilter=.
+ [X] Vignette: use case for compound database.
+ [X] Vignette: example for =mzmatch=.
+ [ ] Vignette: /standard/ workflow with new methods.


* References
