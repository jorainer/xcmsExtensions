#+TITLE: Extensions to the xcms package
#+AUTHOR:    Johannes Rainer
#+EMAIL:     johannes.rainer@eurac.edu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: exports code
#+PROPERTY: session *R*

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+BEGIN_HTML
---
title: "Extensions to the xcms package"
graphics: yes
output:
  BiocStyle::html_document:
    toc_depth: 2
  BiocStyle::pdf_document:
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Extensions to the xcms package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{xcmsExtensions,xcms,faahKO,limma}
  %\VignettePackage{xcmsExtensions}
  %\VignetteKeywords{MassSpectrometry, Metabolomics}
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

#+END_HTML

# #+BEGIN_SRC R :ravel echo=FALSE, results='asis', message=FALSE
#   BiocStyle::markdown()
# #+END_SRC

* How to export this to a =Rmd= vignette			   :noexport:

Use =ox-ravel= to export this file as an R markdown file (=C-c C-e m r=). That
way we don't need to edit the resulting =Rmd= file.

* How to export this to a =Rnw= vignette 			   :noexport:

*Note*: this is deprecated! Use the =Rmd= export instead!

Use =ox-ravel= from the =orgmode-accessories= package to export this file to a
=Rnw= file. After export edit the generated =Rnw= in the following way:

1) Delete all =\usepackage= commands.
2) Move the =<<style>>= code chunk before the =\begin{document}= and before
   =\author=.
3) Move all =%\Vignette...= lines at the start of the file (even before
   =\documentclass=).
4) Replace =\date= with =\date{Modified: 21 October, 2013. Compiled: \today}=
5) Eventually search for all problems with =texttt=, i.e. search for pattern
   ="==.

Note: use =:ravel= followed by the properties for the code chunk headers,
e.g. =:ravel results='hide'=. Other options for knitr style options are:
+ =results=: ='hide'= (hides all output, not warnings or messages), ='asis'=,
  ='markup'= (the default).
+ =warning=: =TRUE= or =FALSE= whether warnings should be displayed.
+ =message=: =TRUE= or =FALSE=, same as above.
+ =include=: =TRUE= or =FALSE=, whether the output should be included into the
  final document (code is still evaluated).

* Working with =svn= and =git=					   :noexport:

First check out the svn repo using git:

=git svn clone svn+ssh://svn@source.gm.eurac.edu/chrisUtils --stdlayout=.

Pull the existing =git= repository to this /new/ repo: from within the folder call

=git pull ~/Projects/git/chrisUtils=

Eventually rebasing it again (shouldn't do anything actually).

=git svn rebase=

Commiting (if there is anything to commit) and push it to svn:

=git svn dcommit=.

Now, if we want to create a tag (say we have done a release).

=git svn tag=.


Based on
http://stackoverflow.com/questions/22527867/adding-svn-remote-to-existing-git-repo.



* Introduction

This package provides some functions and utilities extending the functionality
of the =xcms= Bioconductor package. These functions aim to provide a better
integration into the Bioconductor framework (using as much as possible methods
defined in =ProtGenerics= and methods and classes from =MSnbase=; and also
following Bioconductor's coding- and function-naming conventions). Some of the
concepts and definitions used in this package are from \cite{Smith:2014di}.


* New objects introduced by =xcmsExtensions=

To enable a more streamlined and user-friendly access to MS data, the
=xcmsExtensions= package defines the following objects. Some of these are
redundant in functionality and data content with objects in =xcms= that do
however, in most cases, not provide simple access to all of the data or have
other limitations. The =xcms= package defines for example the =xcmsEIC= class
and the =getEIC= method to extract ion chromatograms from an =xcmsSet=
object. The EIC, by default, is however extracted from the /profile/ matrix that
represents intensity values aggregated in equal-spaced bins in m/z space. In
addition there exists the =rawEIC= method that extracts m/z, scan index and
corresponding intensity values from the /raw/ data, but does not return these as
an =xcmsEIC= object (and does also not report the actual retention time). The
=xcmsExtensions= package tries to solve some of these possible confusions by the
introduction of the below listed classes and their methods.

+ =MSdata=: this is the basic object holding retention time (rt), m/z and
  measured intensities for the rt-mz tuples. To reduce the memory footprint, the
  retention time is internally stored as an =Rle= object, the mz values as
  =numeric= and the intensities as =integer=. By design this object is thought
  to hold only MS data for a subset of a whole MS run, but in principle, it
  could also store all the detected intensities for all m/z and retention/scan
  times. In this latter case the object is somewhat redundant with the =xcmsRaw=
  object, but provides an easier extraction of paired and matched rt, mz and
  intensity values (using the =msData= method).

+ =MSslice=: represents a /wrapper/ object for multiple =MSdata= objects, all
  defining the same area (slice) in the m/z-rt space, but across several
  samples. By design, a =MSslice= object is thought to hold data for the same
  slice in each of the samples of an =xcmsSet= object. Note also that, depending
  on the data, each =MSdata= object might have a slightly different range of m/z
  and rt values.

+ =MSsliceList=: a list of several =MSslice= object. If e.g. different slices
  defined by different mz/rt ranges from a single sample (e.g. from a single
  =xcmsRaw= object), these will be stored and returned in a =MSsliceList=. Such
  an =MSsliceList= object could for example be used to store the MS data of all
  peaks identified across all samples.

* Extracting MS data

In this section we show some examples how (raw or binned) data of one or several
MS runs can be extracted from =xcmsRaw=, =xcmsSet=, =MSsliceList=, =MSslice= or
=MSdata= objects.

First we load the example data set from the =xcms= package.

#+BEGIN_SRC R :ravel results='silent', message=FALSE
  library(xcmsExtensions)
  library(faahKO)
  xset <- faahko
#+END_SRC

As described in the previous section, an =MSdata= object simply stores
intensities for rt-m/z tuples and corresponds thus to some degree to a =xcmsRaw=
object from the =xcms= package. Below we are extracting all of the data
(retention time, m/z and intensity) values from one of the raw files of the
=faahko= data set.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Extract the full data from an xcmsRaw object.
  xraw <- getXcmsRaw(xset, 1)
  msFull <- msData(xraw)
  msFull
#+END_SRC

Alternatively, we could extract only a portion of the data by specifying an mz
value range and an retention time range with the =mzrange= and =rtrange=
arguments.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Extract only a subset of the data (from a slice in M/Z-rt space)
  msSub <- msData(xraw, mzrange=c(300, 350), rtrange=c(2700, 2900))
  msSub
#+END_SRC

We can extract the retention time, mz values and intensity values using the
=rtime=, =mz= and =intensity= methods.

#+BEGIN_SRC R
  ## Get the retention time values
  head(rtime(msSub))
  ## Get the mz values
  head(mz(msSub))
  ## Get the intensity values
  head(intensity(msSub))
#+END_SRC

We could also convert the =MSdata= into a numeric matrix.

#+BEGIN_SRC R
  head(as.matrix(msSub))
#+END_SRC

# Extract the chromatogram, plot the total ion chromatogram and the base peak
# chromatogram.

A chromatogram (i.e. intensities along retention time) can be extracted from the
=MSdata= object using the =getChromatogram= method, or plotted using the
=plotChromatogram= method. In its default setting, the =getChromatogram= method
extracts all intensity and retention time pairs in the =MSdata=, aggregating
intensities with the exact same retention time. The argument =FUN= of the method
allows to specify the function to aggregate the intensities. In the default
setting (=FUN= being =max=) only the maximal intensity for a retention time is
selected. Below we extract the chromatogram for the data sub-set.

#+BEGIN_SRC R :ravel warning=FALSE
  ## Extract the (full) chromatogram; the maximal intensity will be selected
  ## if two or more values have the same retention time. Otherwise, the data
  ## will be returnes /as.is/
  chr <- getChromatogram(msSub)
  head(chr)
  nrow(chr)
#+END_SRC

Sometimes it might also be useful to bin the data in retention time dimension
and aggregate the values within these bins as well. The arguments =nbin= or
=binSize= allow to specify either the number of bins along the retention time
axis, or the size of these bins (with the =bins= argument it would be even
possible to provide the actual bins, but in most instances the =nbin= or
=binSize= arguments should suffice). This binning allows to reduce the amount of
data and to group intensities in discrete, equal sized, bins. All intensities
(along the full M/Z range present in the =MSdata= object) with a retention times
that fall within a bin are aggregated with the =FUN= function. Below we bin the
data of the sub-set into 30 bins along the retention time range.

#+NAME: xcmse-bin-chromatogram
#+BEGIN_SRC R
  ## Bin the values in 30 bins along the retention time range of the MSdata
  chrB <- getChromatogram(msSub, nbin=30)
  head(chrB)
  nrow(chrB)
#+END_SRC

In the example above we the matrix representing the extracted chromatogram has
30 rows, each row representing the aggregated intensities for each bin. Note
that the matrix could also have less than 30 rows, e.g. if no values would be
available for a bin.

We next plot the chromatogram, first without binning and add the binned
chromatogram to that plot. Especially for larger data sets (i.e. with more data
points) binning provides a considerable speed-up to the plotting process.

#+NAME: xcmsExtensions-chromatogram-plot
#+BEGIN_SRC R :ravel fig.align='center', fig.width=7, fig.height=4, fig.cap="Extracted chromatogram for the data sub set. With (blue) and without (black) binning along the retention time axis."
  ## Plot the chromatogram.
  plotChromatogram(msSub, type="l")
  ## Add the binned chromatogram to the plot.
  plotChromatogram(msSub, type="l", col="blue", add=TRUE, nbin=30)
#+END_SRC

With this methods we can also extract the base peak chromatogram
\cite{Smith:2014di} (BPC, the maximal intensity along the full M/Z range for the
same retention time) or the total ion chromatogram (TIC, the sum of all
intensities along the M/Z dimension for the same retention time). We plot these
two for the =MSdata= representing the full data of the first MS run in the
experiment. For the former we can just use the default setting for the =FUN=
method, for the latter we change =FUN= to =sum=.

#+NAME: xcmsExtensions-chromatogram-plot-bpc-tic
#+BEGIN_SRC R :ravel results='hold', fig.align='center', fig.width=7, fig.height=3.5, fig.cap="Base peak chromatogram (BPC) and total ion chromatogram (TIC) for the full data."
  par(mfrow=c(1, 2))
  ## Plot the BPC.
  plotChromatogram(msFull, type="l", main="BPC")
  ## And the TIC.
  plotChromatogram(msFull, type="l", FUN=sum, main="TIC")
#+END_SRC

# Extract the spectrum.
Analogous to the =getChromatogram=, the =getSpectrum= method allows to extract a
spectrum (i.e. intensities, eventually aggregated for identical retention times,
along the M/Z dimension) from an =MSdata= object, enabling also an optional
binning of values in M/Z dimension. In the example below we refine the MS data
slice for the peak from the example above and plot the chromatogram as well as
the spectrum for it. The MS data could alternatively also extracted as a
two-dimensional matrix with the =mapMatrix= method (see further below in /Data
manipulations/ section for an example).

#+NAME: xcmsExtensions-chromatogram-and-spectrum
#+BEGIN_SRC R :ravel results='hold', fig.align='center', fig.width=7, fig.height=3.5, fig.cap="Chromatogram and spectrum for the peak."
  rtr <- c(2550, 2700)
  mzr <- c(300, 330)
  ## Extrac the MS data slice
  msd <- msData(xraw, mzrange=mzr, rtrange=rtr)
  par(mfrow=c(1, 2))
  ## Plot the chromatogram
  plotChromatogram(msd, type="l")
  ## And the spectrum
  plotSpectrum(msd, type="l")
#+END_SRC

The =MSdata= is thus the basic object to store MS data of a single MS
run/sample. Data from different MS runs/samples is represented by, and can be
stored into, a =MSslice= object. This object is supposed to store the data from
the same slice from the 2-dimensional (m/z over rt) MS data across several
samples. In the example below we define a slice representing one of the peaks in
the =faahko= data set shown in Figure 4 in the =xcms= vignette.

Alternatively we could extract an =MSslice= object representing the full MS data
of all samples of an experiment by simply not providing an =rtrange= or
=mzrange=.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Extract the chromatogram of a m/z-rt slice across all samples.
  ## Defining the mz and rt ranges for the peak in the xcms
  ## vignette (Figure 4).
  mzr <- c(300, 330)
  rtr <- c(2550, 2700)
  mss <- msSlice(xset, rtrange=rtr, mzrange=mzr)
  mss
#+END_SRC

We can further subset data in an =MSslice= object using the =subset= method
providing =mzrange= and/or =rtrange=, or we can subset the =MSslice= object to
specific samples using the =[= method. Finally we can also extract single
=MSdata= objects using the =[[= method.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Further subsetting the MSslice object
  mssSub <- subset(mss, rtrange=c(2570, 2590))

  ## Or we can use the [ and [[ methods to subset to samples.
  ## Extract samples 2, 8, 9
  mss[c(2, 8, 9)]

  ## Extract the MSdata representing sample 8
  mss[[8]]
#+END_SRC


Most of the methods defined for =MSdata= objects are also available for
=MSslice= objects. In the example below we thus extract the chromatogram and the
spectrum from the =MSdata= object and get for each of the two as a result a
matrix, rows being either unique retention times or M/Z values and columns
samples.

#+BEGIN_SRC R
  ## Extracting the chromatogram from the MSslice object. To reduce the data points
  ## and enable a better matching of values across samples we use binning on the
  ## retention time and bin the data in 2 second intervals.
  chrM <- getChromatogram(mss, binSize=2)
  head(chrM)

  ## The same with the spectra. Binning into 0.5 M/Z
  spcM <- getSpectrum(mss, binSize=0.5)
  head(spcM)
#+END_SRC

We can also plot the chromatogram and the spectrum with the =plotChromatogram=
and =plotSpectrum= methods. As above, these methods would also allow to plot the
BPC and the TIC as well as the TIS for all samples within an experiment into the
same plot.

#+NAME: xcmsExtensions-MSslice-chromatogram-spectrum-plot
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and spectrum of all samples for the specified MS data slice.", fig.align='center'
  par(mfrow=c(1, 2))
  plotChromatogram(mss, binSize=2, type="l", col="#00000050")
  plotSpectrum(mss, binSize=0.5, type="h", col="#00000050")

#+END_SRC

In addition, we could use the =image= or the =levelplot= method to plot the
chromatogram or spectrum matrix directly.

#+NAME: xcmsExtensions-MSslice-chromatogram-levelplot-plot
#+BEGIN_SRC R :ravel fig.cap="Chromatogram of each sample in the experiment represented as an image plot (levelplot). ", fig.align='center', fig.width=7, fig.height=5
  levelplot(chrM, las=2, xlab="Retention time", ylab="Sample")
#+END_SRC

#+NAME: xcmsExtensions-MSslice-spectrum-levelplot-plot
#+BEGIN_SRC R :ravel fig.cap="Spectrum of each sample in the experiment represented as an image plot (levelplot). ", fig.align='center', fig.width=7, fig.height=5
  levelplot(spcM, las=2, xlab="M/Z", ylab="Sample")
#+END_SRC

# MSsliceList objects
If multiple different ranges (in M/Z and/or retention time space) are defined,
the =msSlice= method would extract =MSslice= object for each of these and return
the results as a =MSsliceList=.

In the example below we extract a slice of MS data for each of the four peaks
from the =xcms= vignette, Figure 3 from all samples.

#+BEGIN_SRC R
  ## Defining the mz and rt ranges.
  mzr <- rbind(c(300.0, 300.3),
               c(301.0, 301.3),
               c(298.0, 298.3),
               c(491.0, 491.4))
  rtr <- rbind(c(3300, 3450),
               c(3300, 3450),
               c(3100, 3250),
               c(3300, 3500))
  ## Extracting the MS data slices; we are extracting the raw,
  ## i.e. unaligned retention times.
  msl <- msSlice(xset, rtrange=rtr, mzrange=mzr, rt="raw")
  msl
#+END_SRC

Plotting the (base peak) chromatogram for each of the slices.

#+NAME: xcmsExtensions-MSsliceList-peaks-chrom-plot
#+BEGIN_SRC R :ravel fig.cap="Base peak chromatogram for each of the MS data slices across all samples.", fig.align='center'
  par(mfrow=c(2, 2))
  lapply(slices(msl), plotChromatogram, type="l", col="#00000080")
#+END_SRC


* Data manipulations

One of the simplest data manipulations is to aggregate intensities in bins along
the M/Z or the retention time axis. This might be done to reduce the amount of
data points e.g. to plot the data. Binning in retention time dimension is also
especially useful to match individual intensities across samples, if the
retention times slightly differ. In the example below we aggregate intensities
in bins of size 1 along the M/Z and along the retention time axis (especially in
M/Z dimension this binning might be too coarse in a real world situation). By
default, the maximal signal is selected for each bin, but this can be changed
with the argument =FUN=.

#+NAME: xcmsExtensions-binning-chrom-spec-plot
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and Spectrum for the MS data sub-set, grey represents the raw data and blue the binned values. Upper row: binned along the M/Z dimension, lower row: in retention time dimension.", fig.align='center'
  ## Using the the same of the MS data from the previous section.
  rtr <- c(2550, 2700)
  mzr <- c(300, 330)
  msd <- msData(xraw, mzrange=mzr, rtrange=rtr)

  ## Bin along the M/Z range
  mzBinned <- binMz(msd, binSize=1)
  ## And along the retention time
  rtBinned <- binRtime(msd, binSize=5)

  ## Plotting
  par(mfrow=c(2, 2))
  plotChromatogram(msd, type="l", col="grey")
  plotChromatogram(mzBinned, type="l", add=TRUE, col="blue", lty=2)
  plotSpectrum(msd, type="l", col="grey")
  plotSpectrum(mzBinned, type="l", add=TRUE, col="blue", lty=2)
  ##
  plotChromatogram(msd, type="l", col="grey")
  plotChromatogram(rtBinned, type="l", add=TRUE, col="blue", lty=2)
  plotSpectrum(msd, type="l", col="grey")
  plotSpectrum(rtBinned, type="l", add=TRUE, col="blue", lty=2)
#+END_SRC

To bin the data matrix in both dimensions, the =binMzRtime= method can be used.

The MS data can also be extracted as a two-dimensional matrix, with rows being
the M/Z and columns the retention time values for each measurement. This might
e.g. be useful to plot the data using the =image= or =levelplot=
functions. Below we first bin the =MSdata= in both, M/Z and retention time,
extract the resulting MS data matrix and plot it. Below we plot the matrix using
the =image= function, to use the =levelplot= we first have to cast the
=dgCMatrix= into a /normal/ matrix using the =as.matrix= function.

#+NAME: xcmsExtensions-binning-mapMatrix-plot
#+BEGIN_SRC R :ravel fig.cal="Image plot of the binned MS data.", fig.align='center'
  ## We bin the data along the retention time in 5 second intervals and into 20
  ## bins along the M/Z dimension.
  M <- mapMatrix(binMzRtime(msd, rtBinSize=5, mzNbin=20))
  image(M, xlab="Retention time", ylab="M/Z")
#+END_SRC

The same binning can also be applied to =MSslice= and =MSsliceList=
objects. For both methods, the =mzrange= or =rtrange= across all samples is
first cut into intervals and the binning is then performed, for each sample
separately, but using the same bins.



* Simple peak/compound identification

One of the major problems in the metabolomics data analysis workflow is the
identification of the compounds. To facilitate this step, the =xcmsExtensions=
package provides an internal, simple, database that enables a fast and easy
identification based on the compound mass.

In the code chunk below we show some basic information on this database, that is
bound to the variable name =scDb= (for /simple compound database/).

#+BEGIN_SRC R :ravel results='hold'
  ## Show some information on the database.
  scDb
#+END_SRC

Some of the methods defined by the =AnnotationDbi= Bioconductor package are
implemented, thus we can ask for the available columns in the database with the
=columns= method or get the SQLite database connection with the =dbconn=
method.

#+BEGIN_SRC R
  ## List the available columns.
  columns(scDb)
#+END_SRC

To retrieve compounds in this database we can use the =compounds= method, that
by default will return all of the available compounds. The =xcmsExtensions=
package implements however also the filtering framework introduced by
Bioconductor's =ensembldb= package. Thus, we can use an =CompoundidFilter= to
select only specific compounds from the database.

#+BEGIN_SRC R
  ## Get all of the compounds from the database.
  allCmps <- compounds(scDb)
  nrow(allCmps)
#+END_SRC

The =compounds= method returns all database columns from the respective database
table from the database. The method's =columns= argument allows to select only
specific columns (selected from the available ones returned by the =columns=
method shown above) that should be returned.

As stated above, we can use this database also for a simple, mass based,
peak/compound identification. For the simplest case, assuming that the measured
peaks is an ion, the =mzmatch= method compares the provided M/Z values
with the masses of all of the compounds in the database and returns for each
M/Z all matching compounds given a user specified
difference threshold (defined with the =mzdev= and =ppm= arguments).
By default, the method returns all matches allowing a difference of 10 ppm.

#+BEGIN_SRC R
  ## Defining compound masses.
  comps <- c(300.1898, 298.1508, 491.2000, 169.13481, 169.1348)

  ## Searching for matches in the database.
  Res <- mzmatch(comps, scDb)

  Res
#+END_SRC

The results are returned as a =list=, elements being a matrix with the match(es)
for each specified mass. The column =idx= of the matrix contains the compound
IDs and the column =deltaMz= the difference between the specified mass (or
calculated mass, assuming the measured M/Z corresponds to that of an ion adduct;
see further below for more details) and the compound's mass. The column =adduct=
indicates the ion adduct that matches the metabolite in the database (in the
example above we assumed that the measured compound is already and ion, thus an
=M= is listed).

In a /real world/ scenario, the measured M/Z value will correspond to that of an
ion adduct of the /real/ metabolite. The =xcmsExtensions= package has the data
from the /ESI MS adducts/ calculator from the Fiehn lab \cite{Huang:1999gb}
integrated and uses this data to convert between M/Z values and masses for all
or some of the most commonly found ion adducts. The methods =adductmz2mass= and
=mass2adductmz= allow to convert between M/Z and mass values of supported ion
adducts (which can be listed using the =supportedIonAdducts= method).

To calculate the mass of the measured compounds, assuming that the =M+H= ion
adduct was measured we can use the =adductmz2mass= method as shown below.

#+BEGIN_SRC R
  ## Calculate the mass assuming the M+H ion was measured.
  adductmz2mass(comps, ionAdduct="M+H")

  ## Calculate the mass assuming that a negative ion adduct was measured.
  adductmz2mass(comps, ionAdduct=supportedIonAdducts(charge="neg"))
#+END_SRC

If ion adduct name(s) are provided to the =mzmatch= method with the =ionAdduct=
argument, the method internally compares all masses for all ion adducts with the
database.

#+BEGIN_SRC R
  ## Match the M/Z, assuming it to correspond to a positive ion adduct, with all
  ## masses in the database
  Res <- mzmatch(comps, scDb, ionAdduct=supportedIonAdducts(charge="pos"))
  ## Remove all non-matching results ensuring that at leas one result is returned
  ## for an input M/Z
  Res <- lapply(Res, function(z){
      if(all(is.na(z$idx)))
          return(z[1, ])
      return(z[!is.na(z$idx), ])
  })

  Res[1:2]
#+END_SRC

In the code chunk below we're defining an
=CompoundidFilter= for the identified compounds of the 4th mass and return its
name and inchi key from the database.

#+BEGIN_SRC R
  ## Define CompoundidFilter for the matches of the selected mass
  cf <- CompoundidFilter(Res[[1]][1, "idx"])

  ## Getting the compounds' names and inchi keys from the database
  cmps <- compounds(scDb, filter=cf, columns=c("name", "inchikey"))
  cmps
#+END_SRC


* Using =xcmsExtensions= for an updated =xcms= data analysis workflow

TODO: use the workflow in =xcms= but use as much as possible the stuff from the
=xcmsExtensions=.

In this section we perform the analysis of the =faahKO= data set described in
the =xcms= package vignette /LC/MS Preprocessing and Analysis with xcms/.

#+BEGIN_SRC R
  ## load the libraries and data
  library(xcms)
  library(xcmsExtensions)
  library(faahKO)
  ## list the files provided by the package
  cdfpath <- system.file("cdf", package="faahKO")
  dir(cdfpath, recursive=TRUE)
#+END_SRC

In contrast to the default workflow, we define a =data.frame= specifying the
input files, associated samples and phenotypes (or genotypes as in the present
setup). Usually, such a table will be saved as a tabulator delimited text file
which is then read with the =read.table= or =read.AnnotatedDataFrame= method.

#+BEGIN_SRC R
  ## Define a phenotype data.frame
  cdffiles <- dir(cdfpath, recursive=TRUE, full.names=TRUE)
  ## Extract the genotype from the file name
  genot <- rep("KO", length(cdffiles))
  genot[grep(cdffiles, pattern="WT")] <- "WT"
  ## And the sample name.
  tmp <- strsplit(cdffiles, split=.Platform$file.sep)
  sampn <- unlist(lapply(tmp, function(z){
      return(gsub(z[length(z)], pattern=".CDF", replacement="", fixed=TRUE))
  }))

  ## And the phenodata table
  pheno <- data.frame(file=cdffiles, genotype=genot, name=sampn)

  head(pheno)
#+END_SRC

Next we create a new =xcmsSet= object with the =xcmsSet= function. This call
will identify peaks in each of the samples. In most instances we might however
change the default peak identification approach with the =centwave= method
\cite{Tautenhahn:2008fx}. In any case, we have to set the sample class
assignment according to the experimental setup so that the peak grouping across
samples is performed as expected. Similar to other data objects defined in
Bioconductor (e.g. the =ExpressionSet=), we can access data in the provided
phenodata table using the =$= operator.

#+BEGIN_SRC R :ravel message=FALSE, warning=FALSE
  ## The default call from the vignette.
  xset <- xcmsSet(files=cdffiles, phenoData=pheno)

  ## Setting the sample class; that's important for the peak grouping
  ## algorithm
  sampclass(xset) <- xset$genotype

  ## At last we define also a color for each of the two genotypes.
  genoColor <- c("#E41A1C80", "#377EB880")
  names(genoColor) <- c("KO", "WT")
#+END_SRC

Next we plot the base peak chromatogram (BPC) and the total ion chromatogram
(TIC) for all of the files to get a global overview of the data. To this end
we're extracting an =MSslice= object without specifying an M/Z and retention
time range, thus returning the full MS data for each sample.

#+BEGIN_SRC R :ravel message=FALSE, warning=FALSE
  ## Get the full MS data from each sample.
  fullData <- msSlice(xset)

  ## Eventually setting the names of the data
  names(fullData) <- sampnames(xset)
#+END_SRC

The BPC and the BPS (base peak spectrum, i.e. the maximum signal across the
retention time range for one M/Z) are shown below.

#+NAME: xcmsExtensions-xcms-wf-bpc-bps
#+BEGIN_SRC R :ravel fig.cap="Base peak chromatogram and base peak spectrum of all samples. Red and blue lines represent KO and WT samples, respectively.", fig.align="center", message=FALSE, warning=FALSE, width=8, height=4
  par(mfrow=c(1, 2))
  plotChromatogram(fullData, binSize=1, col=genoColor[xset$genotype], main="BPC", type="l")
  plotSpectrum(fullData, binSize=0.1, col=genoColor[xset$genotype], main="BPS", type="l")
#+END_SRC

According to the spectrum, there seems to be some difference between the sample
group around an M/Z of about 320. We will extract a slice from the whole MS data
from an M/Z value of 320 to 330, taking the full retention time range.

#+NAME: xcmsExtensions-xcms-wf-mzslice
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and spectrum for the specified M/Z slice.", fig.align="center", message=FALSE, warning=FALSE, width=8, height=4
  ## Extract the slice
  mzs <- msSlice(xset, mzrange=c(320, 330))

  par(mfrow=c(1, 2))
  plotChromatogram(mzs, binSize=1, col=genoColor[xset$genotype], main="BPC", type="l")
  plotSpectrum(mzs, binSize=0.1, col=genoColor[xset$genotype], main="BPS", type="l")
#+END_SRC

Indeed, there is a clear difference between the groups in that slice.

Next we plot the total ion chromatogram (TIC) and total ion spectrum (TIS).

#+NAME: xcmsExtensions-xcms-wf-tic-tis
#+BEGIN_SRC R :ravel fig.cap="Total ion chromatogram and total ion spectrum of all samples. Red and blue lines represent KO and WT samples, respectively.", fig.align="center", message=FALSE, warning=FALSE, width=8, height=4
  par(mfrow=c(1, 2))
  plotChromatogram(fullData, binSize=1, FUN=sum, col=genoColor[xset$genotype], main="TIC", type="l")
  plotSpectrum(fullData, binSize=0.1, FUN=sum, col=genoColor[xset$genotype], main="TIS", type="l")
#+END_SRC

Plotting also boxplots of the signal distribution of all peaks per sample; width
of the boxes relative to the number of peaks.

#+NAME: xcmsExtensions-xcms-boxplot-rawdata
#+BEGIN_SRC R :ravel fig.cap="Distribution of (integrated) peak intensities per sample.", fig.align="center", message=FALSE, warning=FALSE, width=8, height=5
  boxplot(log2(into)~sample, xlab="", data=data.frame(peaks(xset)),
          main="Peak intensity distribution", col=genoColor[xset$genotype],
          varwidth=TRUE, xaxt="n", ylab=expression(log[2]~intensity))
  axis(side=1, at=1:length(xset$name), as.character(xset$name), las=2)
#+END_SRC

Some of the samples show higher overall peak intensities but over and above,
their distribution across samples is comparable. The number of identified peaks
per sample (represented by the box width) varies also between samples.

Next we perform the grouping of the peaks across sample and the retention time
correction. As stated above, setting the class assignment of the samples (using
the =sampclass= method) is crucial, since the default peak grouping algorithm
(=group.density=) requires by default that at a peak has to be present in at
least 30% of the samples in a class in order to be considered a peak (argument
=minfrac=). After retention time correction the peaks are grouped again and
finally missing peak data is filled in.

#+BEGIN_SRC R :ravel message=FALSE, warning=FALSE
  ## Perform the peak grouping across samples.
  xset <- group(xset)

  ## Perform the retention time correction.
  xset <- retcor(xset, family="symmetric")

  ## Group the peaks after retention time correction.
  xset <- group(xset)

  ## Filling missing peak data.
  xset <- fillPeaks(xset)
#+END_SRC

The =groupval= method can be used to access the actual peak intensity values of
the grouped peaks. By default that method returns the index of the corresponding
peak in the =peaks= slot, to return the integrated original (raw) signal of the
peak we can set the =value= argument of the method to =into=. That returns the
/peak intensity matrix/, each column representing a sample, each row a peak.

#+BEGIN_SRC R
  ## Accessing the intensity value of the grouped peaks.
  head(groupval(xset, value="into"))
#+END_SRC

On that matrix we can perform the remaining analyses. We're first evaluating the
signal distribution of the peaks per sample. Note that we add a =+1= to each of
the signal intensities to avoid taking the logarithm of values between 0 and 1,
or even of 0. Also, we replace peak intensities of =0=.

#+NAME: xcmsExtensions-xcms-peak-signal-distribution
#+BEGIN_SRC R :ravel fig.cap="Peak signal distribution per sample.", fig.align="center", width=8, height=5
  peakMat <- groupval(xset, value="into")
  colnames(peakMat) <- as.character(xset$name)

  ## Eventually replacing 0 values with NA.
  peakMat[peakMat == 0] <- NA
  peakMat <- log2(peakMat + 1)

  par(mfrow=c(1, 2))
  ## Density plot
  denses <- apply(peakMat, MARGIN=2, density, na.rm=TRUE)
  Xses <- do.call(cbind, lapply(denses, function(z) z$x))
  Yses <- do.call(cbind, lapply(denses, function(z) z$y))
  matplot(Xses, Yses, ylab="Density", xlab=expression(log[2]~peak~intensity),
          col=genoColor[xset$genotype], type="l", lty=1)
  ## And the boxplot
  boxplot(peakMat, col=genoColor[xset$genotype],
          xaxt="n", ylab=expression(log[2]~peak~intensity))
  axis(side=1, at=1:length(xset$name), xset$name, las=2)
#+END_SRC

The distribution of peak intensities (integrated intensities of the peak area)
between the samples are comparable, but there might be some need for
normalization.

Next we could use more sophisticated tools like =limma= to identify peaks with
significantly different signal (i.e. differently abundant compounds) between the
genotypes.

Below we perform a /differential abundance/ analysis using the methodology
provided by Bioconductor's =limma= package \cite{Smyth:2004to}. The methods in
this package were developed for microarray data analysis, but, it might be as
well applicable to metabolomics data, given that the peak intensity distribution
is similar to the signal distribution usually seen in microarray experiments.

#+BEGIN_SRC R
  ## Loading the limma package
  library(limma)
  ## Limma setup: define the design matrix KO vs WT
  genot <- xset$genotype
  dsgn <- model.matrix(~ 0 + genot)

  dsgn
#+END_SRC

The very simple model above could be further extended to include and account for
e.g. batches in the data etc. Below we fit now the model to the data (the linear
model is fit to each row/peak in the peak matrix). Subsequently we define the
contrasts of interest (i.e. the comparison of the sample groups) and estimate
the p-values for significance of the difference. Finally, we adjust the p-values
for multiple hypothesis testing using the method from Benjamini and Hochberg.

#+BEGIN_SRC R
  ## Fitting the linear model to the data
  fit <- lmFit(peakMat, design=dsgn)

  ## Defining the contrasts of interest, i.e. which sample group we want
  ## to compare against which.
  contrMat <- makeContrasts(KOvsWT=genotKO - genotWT, levels=dsgn)
  fit <- contrasts.fit(fit, contrMat)
  fit <- eBayes(fit)

  ## Adjusting the p-values
  padj <- p.adjust(fit$p.value[, "KOvsWT"], method="BH")
#+END_SRC

We next plot the distribution of raw and adjusted p-values.

#+NAME: xcmsExtensions-xcms-p-value-hist
#+BEGIN_SRC R :ravel fig.cap="Distribution of raw (left) and adjusted p-values (right).", width=8, height=4, fig.align="center"
  par(mfrow=c(1, 2))
  hist(fit$p.value[, "KOvsWT"], breaks=128, main="Raw p-values", col="grey", xlab="p-value")
  hist(padj, breaks=128, xlim=c(0, 1), main="Adjusted p-values", col="grey", xlab="p-value")
#+END_SRC

An enrichment of small p-values is present in the data, indicating peaks with
significant difference in abundances. Except from these, there is an about
uniform distribution of raw p-values, with a slight bias towards bigger
p-values (suggesting eventual /problems/ in the data such as batch effects not
accounted for etc).

Next we create a volcano plot indicating the difference in abundances (in
analogy to microarray analysis called /M/, i.e. a log_{2} fold change) on the
x-axis against its significance on the y-axis.

#+NAME: xcmsExtensions-xcms-volcano
#+BEGIN_SRC R :ravel fig.cap="Volcano plot. Points in the light blue area represent peaks with a more than two-fold difference in abundance at a 5 percent false discovery rate.", width=6, height=6, fig.align="center"
  X <- fit$coefficients[, "KOvsWT"]
  Y <- -log10(padj)
  plot(3, 3, pch=NA, xlab="M", ylab=expression(-log[10](p[BH])),
       xlim=range(X), ylim=range(Y))
  ## Plotting the area we would consider to contain significantly different peaks
  rect(xleft=min(X)-1, xright=-1, ybottom=-log10(0.05), ytop=max(Y)+1, col="#377EB810", border=NA)
  rect(xleft=1, xright=max(X)+1, ybottom=-log10(0.05), ytop=max(Y)+1, col="#377EB810", border=NA)
  abline(h=-log10(0.05), col="#377EB880", lty=2)
  abline(v=c(-1, 1), col="#377EB880", lty=2)
  ## Plotting the points.
  points(X, Y, col="#00000030", pch=16)
  ## Plotting the FDR axis
  Yticks <- pretty(Y)
  Yticks <- Yticks[-length(Yticks)]
  Ylabs <- 100*(10^-Yticks)
  axis(side=4, at=Yticks, label=format(Ylabs, digits=2, scientific=TRUE), cex=par("cex.axis"), las=2)
  mtext(side=4, line=4.2, text="% FDR", cex=par("cex.lab"))

#+END_SRC

We next select the peaks with a significant difference in abundance (more than
two-fold different at a 5 percent FDR) and perform a simple compound
identification for these, based on their M/Z value.

#+BEGIN_SRC R
  ## Select significant peaks
  idx <- which(padj < 0.05 & abs(fit$coefficients[, "KOvsWT"]) > 1)
  ## Compiling the result table
  resTable <- cbind(idx=idx, groups(xset)[idx, ],
                    rawp=fit$p.value[idx, "KOvsWT"],
                    padj=padj[idx],
                    M=fit$coefficients[idx, "KOvsWT"])

  ## Performing the compound identification using the mzmatch method and the
  ## internal SimpleCompoundDb based on the median M/Z value and accepting a
  ## ppm of 20
  comps <- mzmatch(resTable[, "mzmed"], mz=scDb, ppm=20, mzdev=0.01)
  ## Getting the names for the identified compounds.
  compNames <- lapply(comps, function(z){
      if(any(is.na(z[, 1])))
          return(NA)
      tmp <- compounds(scDb, columns="name", filter=CompoundidFilter(z[, 1]))
      return(tmp[, "name"])
  })
  ## Combine multiple compounds into a single one.
  compNames <- lapply(compNames, function(z){
      return(paste(z, collapse="; "))
  })
  comps <- lapply(comps, function(z){
      return(c(id=paste(z[, 1], collapse="; "),
               deltaMz=paste(z[, 2], collapse="; ")))
  })
  ## Combine to the final result table
  resTable <- data.frame(do.call(rbind, comps),
                         name=unlist(compNames, use.names=FALSE),
                         resTable, stringsAsFactors=FALSE)
  ## Order the table by significance
  resTable <- resTable[order(resTable$rawp), ]
#+END_SRC

The top 6 most significant peaks are shown below; none of them was identified by
their M/Z value.

#+BEGIN_SRC R
  head(resTable[, c("id", "mzmed", "rtmed", "padj", "M")])
#+END_SRC

At last we plot the chromatogram and the spectrum for the first peak. To this
end we first extract the MS data from the =xcmsSet= object for the slice defined
by the M/Z and retention time of the peak, extending these ranges a little such
that we can see also the neighborhood of the peak.

#+BEGIN_SRC R
  ## Extracting an MSslice from the xcmsSet object
  rtr <- as.numeric(resTable[1, c("rtmin", "rtmax")])
  mzr <- as.numeric(resTable[1, c("mzmin", "mzmax")])

  ## Extract the slice extending the ranges a little.
  mss <- msSlice(xset, rtrange=grow(rtr, 10), mzrange=grow(mzr, 2))
#+END_SRC

#+NAME: xcmsExtensions-xcms-first-peak
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and spectrum of the most significant peak.", width=8, height=5, fig.align="center", message=FALSE, warning=FALSE
  par(mfrow=c(1, 2))
  ## chromatogram
  plotChromatogram(mss, type="l", col=genoColor[as.character(xset$genotype)])
  ## highlighting the peak area.
  abline(v=rtr, col="#00000020", lty=2)
  ## spectrum
  plotSpectrum(mss, type="h", col=genoColor[as.character(xset$genotype)])
  abline(v=mzr, col="#00000020", lty=2)
#+END_SRC


And also for the second peak.

#+NAME: xcmsExtensions-xcms-second-peak
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and spectrum of the 2nd significant peak.", width=8, height=5, fig.align="center", message=FALSE, warning=FALSE
  rtr <- as.numeric(resTable[2, c("rtmin", "rtmax")])
  mzr <- as.numeric(resTable[2, c("mzmin", "mzmax")])

  ## Extract the slice extending the ranges a little.
  mss <- msSlice(xset, rtrange=grow(rtr, 10), mzrange=grow(mzr, 2))

  par(mfrow=c(1, 2))
  plotChromatogram(mss, type="l", col=genoColor[as.character(xset$genotype)])
  ## highlighting the peak area.
  abline(v=rtr, col="#00000020", lty=2)
  ## spectrum
  plotSpectrum(mss, type="h", col=genoColor[as.character(xset$genotype)])
  abline(v=mzr, col="#00000020", lty=2)
#+END_SRC

Surprisingly, the peaks don't look very much aligned (i.e. retention time
corrected).

Plotting the MS data for the most significant peak before and after retention
time correction.

#+NAME: xcmsExtensions-xcms-first-peak-before-affter-rt
#+BEGIN_SRC R :ravel fig.cap="Chromatogram and spectrum of the most significant peak before (left) and after (right) retention time correction.", width=8, height=5, fig.align="center", message=FALSE, warning=FALSE
  rtr <- as.numeric(resTable[1, c("rtmin", "rtmax")])
  mzr <- as.numeric(resTable[1, c("mzmin", "mzmax")])

  ## Extract the slice from the data before retention time correction
  mssBefore <- subset(fullData, rtrange=grow(rtr, 10), mzrange=grow(mzr, 2))

  mssAfter <- msSlice(xset, rtrange=grow(rtr, 10), mzrange=grow(mzr, 2))

  par(mfrow=c(1, 2))
  plotChromatogram(mssBefore, type="l", col=genoColor[as.character(xset$genotype)])
  abline(v=rtr, col="#00000020", lty=2)
  ## After retention time correction.
  plotChromatogram(mssAfter, type="l", col=genoColor[as.character(xset$genotype)])
  abline(v=rtr, col="#00000020", lty=2)
#+END_SRC

Retention time correction was not able to align that peak properly. Checking
also for peaks listed in the original vignette from the =xcms= package.

* Alternative way to access data in =xcmsRaw= objects

The =getData= method is an alternative method that can be used to extract paired
retention time, m/z and intensity values from an =xcmsRaw= object. The advantage
over the =msData= method described in the previous method is, that it allows
also a sub-setting by intensities.

Loading the libraries and the =xcmsRaw= object.

#+BEGIN_SRC R :ravel results='silent', message=FALSE
  library(xcmsExtensions)
  library(faahKO)
  xset <- faahko
  ## Getting the raw data for the first data file.
  xraw <- getXcmsRaw(xset)
#+END_SRC

The raw data of an LC/GC-MS run is stored in an =xcmsRaw= object, more
specifically, in the slots =@scantime=, =@env$mz=, =@env$intensity=. Extracting
data from such a =xcmsRaw= object can however be somewhat cumbersome, especially
when we want to extract only (eventually multiple) sub-sets of data. Also, for
memory reasons, the length of the =@scantime= slot does not match the length of
the =@env$mz= slot as it stores only the distinct scan/measurement time points.
We can however use the =scantimes= method to extract a numeric vector that
matches the length of the =@env$mz= and =@env$intensity= slots, thus specifying
the scan time for each of these data points.

#+BEGIN_SRC R
  ## What's the length of data points we have?
  length(xraw@env$mz)
  ## And the length of scan times?
  length(xraw@scantime)

  ## Extract the scan times matching the individual data points.
  head(scantimes(xraw))
  length(scantimes(xraw))
#+END_SRC

The data in an R-object should however not be accessed directly (i.e. accessing
the slots), but ideally through an /getter/ methods. Thus, to extract the raw
data from an =xcmsRaw= object we can use the =getData= method. We could also use
the =rawMat= method defined in the =xcms= package, but the =getData= should be
preferably used, as it is also faster and extracts always correct sub-sets if
sub-setting is done on retention time ranges.

#+BEGIN_SRC R
  ## Get the full data from the object
  dim(getData(xraw))
  head(getData(xraw))

  ## Extract only a subset of data specified by an retention time range.
  datmat <- getData(xraw, rtrange=c(2509, 2530))
  dim(datmat)

  ## We can also specify both, a retention time and a mz range.
  datmat <- getData(xraw, rtrange=c(2509, 2530), mzrange=c(301, 302.003))
#+END_SRC

Besides sub-setting by retention time and m/z ranges it is also possible to
extract data sub-sets defined by an intensity range.

#+BEGIN_SRC R
  ## Use and intensity range: all with a signal higher than 300
#+END_SRC

And finally, we can also specify multiple retention time and or m/z (or
intensity) ranges to extract multiple sub-sets.

#+BEGIN_SRC R

#+END_SRC

Note that, if we load an =xcmsRaw= object for a =xcmsSet= object after having
applied retention time correction, the retention times (scan time) we extract
from that object will correspond to the corrected ones.

#+BEGIN_SRC R :ravel results='hold'
  ## Grouping (alignment) of peaks/features
  xset <- group(xset)
  ## Retention time correction
  xset <- retcor(xset)
  ## Extract "raw" data; corrected retention times will be applied to the raw data.
  xraw2 <- getXcmsRaw(xset)
#+END_SRC

Extracting data by directly accessing the slots of an R-object is however no


* Standardization of names etc					   :noexport:

We base the naming convention of methods classes etc on the review from Smith et
al. \cite{Smith:2014di} and will implement as many methods and classes as
possible (and meaningful) from the =ProtGenerics= and =MSnbase= packages.

+ *Definitions*
  + *chromatogram*: intensity /vs/ (retention) time of the analytes.
  + *(mass) spectrum*: intensity /vs/ m/z; all points with a single retention time
    value (MS1, can be measured by MSMS again -> MS2).
  + *total ion spectrum (TIS)*: sum of all ion counts (intensity) with one RT
    (i.e. the sum of all spectra). Basically the sum of the signal per m/z over
    all RT resulting in intensity /vs/ m/z (intensity /vs/ m/z).
  + *total ion chromatogram (TIC)*: sum of all ion chromatograms, i.e. sum of ion
    counts per RT over all m/z (intensity /vs/ RT).
  + *extracted ion chromatogram (XIC)*: chromatogram (intensity /vs/ RT) for a
    fixed m/z.
  + *base peak chromatogram (BPC)*: most intense signal across m/z for each RT
    (intensity /vs/ RT).
  + *isotope trace*: signal produced by a single ion of a single analyte at a
    particular charge state, fixed m/z (intensity /vs/ RT for a fixed m/z). Sort
    of a peak in RT for a fixed m/z.
  + *isotopic envelope trace* a.k.a. *feature*: group of isotopic traces of a
    single analyte at a particular charge state (intensity /vs/ RT /vs/
    m/z). Represents all intensities/peaks in a RT, m/z region.

+ =ProtGenerics=

+ =MSnbase=

  - =MSmap= object.


* Creation of an =SimpleCompoundDb=				   :noexport:
:PROPERTIES:
:eval: never
:END:

Assuming we have downloaded the whole HMDB (http://www.hmdb.ca/) content as a
zip (http://www.hmdb.ca/downloads) and have unzipped it to the folder
=~/tmp/HMDB=. Note that we have to delete the large xml file containing all of
the metabolites first, i.e. the /hmdb_metabolites.xml/ file.

#+BEGIN_SRC R
  dbFile <- xcmsExtensions:::.createSimpleCompoundDb(hmdbPath="~/tmp/HMDB",
                                                     hmdbVersion="2016-04-03")
#+END_SRC

Alternatively we can also split the file into small peaces... hm , doesn't work!!!

=csplit hmdb_metabolites.xml '/^<?xml version="1.0" encoding="UTF-8"?>$/'=

=awk '/<?xml/{filename=NR".xml"}; {print > filename}' hmdb_metabolites.xml=


* TODOs								   :noexport:

** CANCELED Implement =getXIC= methods.
   CLOSED: [2016-04-05 Tue 15:22]
   - State "CANCELED"   from "TODO"       [2016-04-05 Tue 15:22] \\
     Can all be done with the =plotChromatogram= method.
+ [ ] =getXIC=: providing rtrange, mzrange, extract the ion chromatogram.
+ [ ] =getTIC=:
+ [ ] =getBPC=:
+ [ ] =getTIS=:
+ [ ] =getWhatever=: just extract everything from the 2-dimensional thing.

** TODO Implement =calibrate= method.
** DONE Stuff to work with the /HMDB/ xml files?
   CLOSED: [2016-04-05 Tue 15:22]
   - State "DONE"       from "TODO"       [2016-04-05 Tue 15:22]
** DONE =scantime= method for =xcmsRaw=.
   CLOSED: [2016-03-30 Wed 15:53]
   - State "DONE"       from "TODO"       [2016-03-30 Wed 15:53]
** DONE =MSslice= class [6/6]
   CLOSED: [2016-04-05 Tue 15:22]
   - State "DONE"       from "TODO"       [2016-04-05 Tue 15:22]
The =MSslice= represents a part of the data defined by an =rtrange= and an
=mzrange=. Would be nice to store that for one such range across several
files. But this again requires that the times AND mz are synced.

+ [X] Extract such an object using =msSlice= from an =xcmsSet= or =xcmsRaw=
  object.
+ [X] =plot= method: two different ones, one for the spectrum (intensity vs mz)
  and one for the chromatogram (intensity vs rt). In both cases we have to sum
  up intensities for /close/ values either on rt or on mz.
+ [X] Documentation.
+ [X] Examples to the vignette.
+ [X] =binMz=, =binRt= and both.
+ [X] =subset= method to subset a =MSslice= by =mzrange=, =rtrange= or both.

** TODO =MSsliceList= class [5/7]

Represents multiple =MSslice= objects. Each one defined by its own mz/rt region.

+ [X] Implement =[= to subset the list.
+ [X] Implement =[[= to extract individual (single) elements.
+ [ ] Add names slot.
+ [X] Documentation.
+ [X] Examples to the vignette.
+ [X] =binMz=, =binRt= and both.

** DONE =MSdata= class [8/8]
   CLOSED: [2016-04-05 Tue 15:22]
   - State "DONE"       from "TODO"       [2016-04-05 Tue 15:22]
+ [X] =chromatogram=: plot the chromatogram of the =MSdata= object.
+ [X] =getChromatogram=: extract a chromatogram.
+ [X] =plotChromatogram=: plot a chromatogram; uses =getChromatogram= to extract
  the chromatogram.
+ [X] =getSpectrum=: extract a spectrum (intensity over m/z for one given
  (small) rt range).
+ [X] =plotSpectrum=: plot that.
+ [X] =msMap= method for =MSdata=: convert the =MSdata= into a =MSmap=.
+ [X] =binMzRtime= method to bin in both dimensions!
+ [X] =mapMatrix= method to extract a matrix representing the data (two-d).


** DONE Easy identification database. [2/2]
   CLOSED: [2016-04-13 Wed 15:15]
   - State "DONE"       from "TODO"       [2016-04-13 Wed 15:15]
+ [X] Create a simple database (table) with mass, internal id, external id,
  source and name to easily and fast identify peaks based on mass alone.
+ [X] Implement a method =mzmatch= that allows to
  - Identify e.g. peaks in the data (if applied to an =xcmsSet= object).
  - Annotate peaks (if applied to an annotation database object).
+ [ ] =subset= method to subset a =MSdata= by =mzrange=, =rtrange= or both.

** DONE shiny app to visualize the data of an =xcmsSet= or =xcmsRaw= object.
   CLOSED: [2016-04-18 Mon 15:19]
   - State "DONE"       from "TODO"       [2016-04-18 Mon 15:19]
+ Provide a =xcmsSet= object and display a page showing the base peak
  chromatogram and spectrum.
+ Below two sliders to select the mz and rt range.

** TODO Finish help and vignette [4/5]

+ [X] Help on =SimpleCompoundDb=.
+ [X] Help on =CompoundidFilter=.
+ [X] Vignette: use case for compound database.
+ [X] Vignette: example for =mzmatch=.
+ [ ] Vignette: /standard/ workflow with new methods.


** DONE Subset MSslice objects =[]=.
   CLOSED: [2016-04-28 Thu 07:15]
   - State "DONE"       from "TODO"       [2016-04-28 Thu 07:15]
** DONE Make =MSslice= extending some =Biobase= object to have pheno data implemented.
   CLOSED: [2016-04-28 Thu 07:15]
   - State "DONE"       from "TODO"       [2016-04-28 Thu 07:15]
Extending =eSet= might be problematic; what about =pSet=?

** DONE =mzmatch= include Fiehn lab stuff
   CLOSED: [2016-04-28 Thu 07:15]
   - State "DONE"       from "TODO"       [2016-04-28 Thu 07:15]
+ [X] Include the M+- info from the Fiehn lab.
+ [X] Extend the =mzmatch= method to allow matches using +-.
  The idea would be to generate multiple versions of the input values by
  subtracting/adding something, perform a search for each and return the result
  as a list.

* References
